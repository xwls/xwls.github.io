{"meta":{"title":"小汪老师","subtitle":"随笔、记录、踩坑、转载","description":"","author":"Wang","url":"https://xwls.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-08-18T03:56:18.118Z","updated":"2023-08-18T03:56:18.118Z","comments":false,"path":"about/index.html","permalink":"https://xwls.github.io/about/index.html","excerpt":"","text":"个人详细介绍 &#123; name: &#39;xwls&#39; age: 29, gender: &#39;男&#39;, profession: &#39;后端开发&#39;, experience: &#39;7年&#39;, address: &#39;山东省临沂市&#39;, github: &#39;https://github.com/xwls&#39;, blog: [ &#39;https://xwls.github.io&#39;, &#39;https://xwls.netlify.app&#39; ], email: &#39;wangzengwei@88.com&#39;, skills: [ [&#39;Html&#39;, &#39;Javascript&#39;, &#39;jQuery&#39;, &#39;CSS&#39;, &#39;ES6&#39;, &#39;Node&#39;], [&#39;Java&#39;, &#39;Golang&#39;], [&#39;Maven&#39;,&#39;Gradle&#39;], [&#39;Git&#39;, &#39;SVN&#39;], [&#39;Vue&#39;], [&#39;Spring&#39;, &#39;SpringBoot&#39;, &#39;Mybatis&#39;, &#39;Hibernate&#39;, &#39;jpa&#39;], [&#39;Beego&#39;, &#39;go-zero&#39;, &#39;gorm&#39;, &#39;xorm&#39;], [&#39;Oracle&#39;, &#39;MySql&#39;, &#39;Mongo&#39;, &#39;Redis&#39;], [&#39;Dubbo&#39;, &#39;SpringCloud&#39;, &#39;Docker&#39;, &#39;Kubernetes&#39;] ] &#125;"},{"title":"categories","date":"2022-10-10T03:21:10.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"categories/index.html","permalink":"https://xwls.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的收藏","date":"2023-08-18T03:56:18.118Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"friends/index.html","permalink":"https://xwls.github.io/friends/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-08-18T03:56:18.118Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"links/index.html","permalink":"https://xwls.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-08-18T03:56:18.118Z","updated":"2023-08-18T03:56:18.118Z","comments":false,"path":"repository/index.html","permalink":"https://xwls.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-10-10T03:21:45.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"tags/index.html","permalink":"https://xwls.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Ubuntu 22.04 安装 ceph 集群","slug":"ceph-cluster-install","date":"2023-02-16T02:43:34.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2023/02/16/ceph-cluster-install/","link":"","permalink":"https://xwls.github.io/2023/02/16/ceph-cluster-install/","excerpt":"在 Ubuntu 22.04 使用 cephadm 安装 ceph 集群，并配置为 k8s 的存储类。","text":"在 Ubuntu 22.04 使用 cephadm 安装 ceph 集群，并配置为 k8s 的存储类。 准备准备了 3 台服务器用于安装 ceph 集群，服务器信息如下： 主机名 IP 配置 磁盘 ceph-node1 192.168.56.31 2 vCPU；2 GiB 系统盘 40G + 数据盘 6G * 2 ceph-node2 192.168.56.32 2 vCPU；2 GiB 系统盘 40G + 数据盘 6G * 2 Ceph-node3 192.168.56.33 2 vCPU；2 GiB 系统盘 40G + 数据盘 6G * 2 修改 hosts 文件修改所有服务器的 hosts 文件 vim /etc/hosts 192.168.56.31 ceph-node1 192.168.56.32 ceph-node2 192.168.56.33 ceph-node3 时间同步所有服务器全部执行： # 启用时间同步 timedatectl set-ntp true # 设置时区 Asia/Shanghai timedatectl set-timezone Asia/Shanghai # 查看状态 timedatectl status 安装 Docker 使用 apt 安装 docker-ce，所有服务器全部安装 apt update apt install docker-ce -y 配置 docker 国内镜像地址 tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; &#123; &quot;registry-mirrors&quot;: [&quot;https://y037t07z.mirror.aliyuncs.com&quot;] &#125; EOF systemctl restart docker SSH 免密登录开启 ssh 免密登录，所有服务器都需要执行 # 生成 ssh 密钥 ssh-keygen -t rsa # 拷贝密钥 ssh-copy-id ceph-node1 ssh-copy-id ceph-node2 ssh-copy-id ceph-node3 # 测试 使用 cephadm 安装 ceph 集群# 安装 cephadm apt install cephadm -y # 启用集群 cephadm bootstrap --mon-ip 192.168.56.31 # 安装 ceph-cli apt install ceph-common -y # 集群状态信息 ceph -s # 查看节点信息 ceph orch host ls # 拷贝公钥 ssh-copy-id -f -i /etc/ceph/ceph.pub ceph-node2 ssh-copy-id -f -i /etc/ceph/ceph.pub ceph-node3 # 添加节点 ceph orch host add ceph-node2 ceph orch host add ceph-node3 # 查看节点信息 ceph orch host ls # 添加所有可用磁盘到集群 ceph orch apply osd --all-available-devices # 查看 osd 状态 ceph osd tree ceph dashboardhttps://192.168.56.31:8443 创建一个用户 ceph auth get-or-create client.kubernetes mon &#39;profile rbd&#39; osd &#39;profile rbd pool=kube&#39; mgr &#39;profile rbd pool=kube&#39; [client.kubernetes] key = AQDpuN1jIlPBABAAaGhYtIUSonIiHirrM9SFkQ== ceph mon dump epoch 3 fsid 4e38b228-a375-11ed-bb7f-1f327548c6fd last_changed 2023-02-03T03:56:20.328724+0000 created 2023-02-03T03:47:49.394295+0000 min_mon_release 17 (quincy) election_strategy: 1 0: [v2:192.168.56.31:3300/0,v1:192.168.56.31:6789/0] mon.ceph-node1 1: [v2:192.168.56.32:3300/0,v1:192.168.56.32:6789/0] mon.ceph-node2 2: [v2:192.168.56.33:3300/0,v1:192.168.56.33:6789/0] mon.ceph-node3 csi-config-map.yaml apiVersion: v1 kind: ConfigMap data: config.json: |- [ &#123; &quot;clusterID&quot;: &quot;4e38b228-a375-11ed-bb7f-1f327548c6fd&quot;, &quot;monitors&quot;: [ &quot;192.168.56.31:6789&quot;, &quot;192.168.56.32:6789&quot;, &quot;192.168.56.33:6789&quot; ] &#125; ] metadata: name: ceph-csi-config kubectl apply -f csi-config-map.yaml csi-kms-config-map.yaml apiVersion: v1 kind: ConfigMap data: config.json: |- &#123;&#125; metadata: name: ceph-csi-encryption-kms-config kubectl apply -f csi-kms-config-map.yaml ceph-config-map.yaml apiVersion: v1 kind: ConfigMap data: ceph.conf: | [global] auth_cluster_required = cephx auth_service_required = cephx auth_client_required = cephx # keyring is a required key and its value should be empty keyring: | metadata: name: ceph-config kubectl apply -f ceph-config-map.yaml csi-rbd-secret.yaml apiVersion: v1 kind: Secret metadata: name: csi-rbd-secret namespace: default stringData: userID: kubernetes userKey: AQDpuN1jIlPBABAAaGhYtIUSonIiHirrM9SFkQ== kubectl apply -f csi-rbd-secret.yaml $ kubectl apply -f &lt;https://raw.githubusercontent.com/ceph/ceph-csi/master/deploy/rbd/kubernetes/csi-provisioner-rbac.yaml&gt; $ kubectl apply -f &lt;https://raw.githubusercontent.com/ceph/ceph-csi/master/deploy/rbd/kubernetes/csi-nodeplugin-rbac.yaml&gt; $ wget &lt;https://raw.githubusercontent.com/ceph/ceph-csi/master/deploy/rbd/kubernetes/csi-rbdplugin-provisioner.yaml&gt; $ kubectl apply -f csi-rbdplugin-provisioner.yaml $ wget &lt;https://raw.githubusercontent.com/ceph/ceph-csi/master/deploy/rbd/kubernetes/csi-rbdplugin.yaml&gt; $ kubectl apply -f csi-rbdplugin.yaml csi-rbd-sc.yaml apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: csi-rbd-sc provisioner: rbd.csi.ceph.com parameters: clusterID: b9127830-b0cc-4e34-aa47-9d1a2e9949a8 pool: kubernetes imageFeatures: layering csi.storage.k8s.io/provisioner-secret-name: csi-rbd-secret csi.storage.k8s.io/provisioner-secret-namespace: default csi.storage.k8s.io/controller-expand-secret-name: csi-rbd-secret csi.storage.k8s.io/controller-expand-secret-namespace: default csi.storage.k8s.io/node-stage-secret-name: csi-rbd-secret csi.storage.k8s.io/node-stage-secret-namespace: default reclaimPolicy: Delete allowVolumeExpansion: true mountOptions: * discard","categories":[{"name":"云原生","slug":"云原生","permalink":"https://xwls.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://xwls.github.io/tags/k8s/"}]},{"title":"k8s 通过 Ingress 进行灰度发布","slug":"k8s-ingress-canary","date":"2023-02-02T03:03:34.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2023/02/02/k8s-ingress-canary/","link":"","permalink":"https://xwls.github.io/2023/02/02/k8s-ingress-canary/","excerpt":"k8s 通过 Ingress 通过设置 权重&#x2F;请求头 进行灰度发布。","text":"k8s 通过 Ingress 通过设置 权重&#x2F;请求头 进行灰度发布。 部署 Deployment V1 应用本步骤指导你如何部署 Deployment V1 应用，并使用 Ingress 实现 Deployment V1 应用的外部访问。 执行如下命令，创建名为 app-v1.yaml 的 YAML 文件。 apiVersion: v1 kind: Service metadata: name: my-app-v1 labels: app: my-app spec: ports: - name: http port: 80 targetPort: http selector: app: my-app version: v1.0.0 --- apiVersion: apps/v1 kind: Deployment metadata: name: my-app-v1 labels: app: my-app spec: replicas: 1 selector: matchLabels: app: my-app version: v1.0.0 template: metadata: labels: app: my-app version: v1.0.0 annotations: prometheus.io/scrape: &quot;true&quot; prometheus.io/port: &quot;9101&quot; spec: containers: - name: my-app image: registry.cn-hangzhou.aliyuncs.com/containerdemo/containersol-k8s-deployment-strategies ports: - name: http containerPort: 8080 - name: probe containerPort: 8086 env: - name: VERSION value: v1.0.0 livenessProbe: httpGet: path: /live port: probe initialDelaySeconds: 5 periodSeconds: 5 readinessProbe: httpGet: path: /ready port: probe periodSeconds: 5 执行如下命令，部署 Deployement V1 应用。 kubectl apply -f app-v1.yaml 执行如下命令，创建名为 ingress-v1.yaml 的 Ingress YAML 文件。 将如下代码复制到文件中，并将 hots 参数中的集群id修改为k8s集群id。 说明：您可在云产品资源列表中查看 k8s 集群id。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: my-app labels: app: my-app spec: rules: - host: my-app.集群id.cn-shanghai.alicontainer.com http: paths: - backend: service: name: my-app-v1 port: number: 80 path: / pathType: Prefix 执行如下命令，部署 Ingress 资源。 kubectl apply -f ingress-v1.yaml 执行如下命令，进行测试。 curl my-app.&lt;集群id&gt;.cn-shanghai.alicontainer.com 返回结果如下，表示您已成功访问到 Deployment V1 应用。 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 部署 Deployment V2 应用本步骤指导你如何部署 Deployment V2 应用。 执行如下命令，创建名为 app-v2.yaml 的 YAML 文件。将如下代码复制到文件中。 apiVersion: v1 kind: Service metadata: name: my-app-v2 labels: app: my-app spec: ports: - name: http port: 80 targetPort: http selector: app: my-app version: v2.0.0 --- apiVersion: apps/v1 kind: Deployment metadata: name: my-app-v2 labels: app: my-app spec: replicas: 1 selector: matchLabels: app: my-app version: v2.0.0 template: metadata: labels: app: my-app version: v2.0.0 annotations: prometheus.io/scrape: &quot;true&quot; prometheus.io/port: &quot;9101&quot; spec: containers: - name: my-app image: registry.cn-hangzhou.aliyuncs.com/containerdemo/containersol-k8s-deployment-strategies ports: - name: http containerPort: 8080 - name: probe containerPort: 8086 env: - name: VERSION value: v2.0.0 livenessProbe: httpGet: path: /live port: probe initialDelaySeconds: 5 periodSeconds: 5 readinessProbe: httpGet: path: /ready port: probe periodSeconds: 5 执行如下命令，部署 Deployement V2 应用。 kubectl apply -f app-v2.yaml 按照权重策略灰度到 Deployment V2 应用本步骤指导你如何按照权重策略灰度到 Deployment V2 应用。 执行如下命令，创建名为 ingress-v2-canary-weigth.yaml 的 YAML 文件。将如下代码复制到文件中，并将 hots 参数中的集群id修改为k8s 集群id。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: my-app-canary labels: app: my-app annotations: # Enable canary and send 10% of traffic to version 2 nginx.ingress.kubernetes.io/canary: &quot;true&quot; nginx.ingress.kubernetes.io/canary-weight: &quot;10&quot; spec: rules: - host: my-app.集群id.cn-shanghai.alicontainer.com http: paths: - backend: service: name: my-app-v2 port: number: 80 path: / pathType: Prefix 执行如下命令，部署 Ingress 资源。 kubectl apply -f ingress-v2-canary-weigth.yaml 执行如下命令进行测试。 while sleep 0.1;do curl my-app.&lt;集群id&gt;.cn-shanghai.alicontainer.com; done 返回结果如下，有 10% 返回版本为 v2.0.0，表示已成功按照权重策略灰度到 Deployment V2 应用。按 CTRL+C 键退出。 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 Host: my-app-v2-648947bdcb-2z4s5, Version: v2.0.0 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 Host: my-app-v2-648947bdcb-2z4s5, Version: v2.0.0 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 按照 Header 策略灰度到 Deployment V2 应用本步骤指导你如何按照 Header 策略灰度到 Deployment V2 应用。 执行如下命令，创建名为 ingress-v2-canary-header.yaml 的 YAML 文件。将如下代码复制到文件中，并将 hots 参数中的集群id 修改为 k8s 集群id。 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: my-app-canary labels: app: my-app annotations: # Enable canary and send traffic with headder x-app-canary to version 2 nginx.ingress.kubernetes.io/canary: &quot;true&quot; nginx.ingress.kubernetes.io/canary-by-header: &quot;x-app-canary&quot; nginx.ingress.kubernetes.io/canary-by-header-value: &quot;true&quot; spec: rules: - host: my-app.集群id.cn-shanghai.alicontainer.com http: paths: - backend: service: name: my-app-v2 port: number: 80 path: / pathType: Prefix 执行如下命令，部署 Ingress 资源。 kubectl apply -f ingress-v2-canary-header.yaml 执行如下命令，并将命令中的集群id 修改为 k8s 集群id，进行测试。 curl my-app.&lt;集群id&gt;.cn-shanghai.alicontainer.com 返回结果如下，访问到 Deployment V1 应用。 Host: my-app-v1-6fc68db67d-xd2kf, Version: v1.0.0 执行如下命令，并将命令中的集群id 修改为 k8s 集群id，设置新的 header。 curl my-app.&lt;集群id&gt;.cn-shanghai.alicontainer.com -H &quot;x-app-canary: true&quot; 返回结果如下，访问到 Deployment V2 应用，表示已成功按照 Header 策略灰度到 Deployment V2 应用。 Host: my-app-v2-648947bdcb-2z4s5, Version: v2.0.0","categories":[{"name":"云原生","slug":"云原生","permalink":"https://xwls.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://xwls.github.io/tags/k8s/"},{"name":"Ingress","slug":"Ingress","permalink":"https://xwls.github.io/tags/Ingress/"},{"name":"灰度","slug":"灰度","permalink":"https://xwls.github.io/tags/%E7%81%B0%E5%BA%A6/"}]},{"title":"k8s 存储类 nfs 网络存储","slug":"k8s-storgeclass-nfs","date":"2023-02-02T00:46:39.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2023/02/02/k8s-storgeclass-nfs/","link":"","permalink":"https://xwls.github.io/2023/02/02/k8s-storgeclass-nfs/","excerpt":"将 nfs 网络存储设置为 k8s 的默认存储类。","text":"将 nfs 网络存储设置为 k8s 的默认存储类。 环境 使用 https://killercoda.com/playgrounds/scenario/kubernetes 的 k8s 作为测试环境 k8s 集群包含以下两个节点 controlplane，IP：172.30.1.2 node01：IP：172.30.2.2 kubectl get nodes -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME controlplane Ready control-plane 6d11h v1.26.0 172.30.1.2 &lt;none&gt; Ubuntu 20.04.5 LTS 5.4.0-131-generic containerd://1.6.12 node01 Ready &lt;none&gt; 6d10h v1.26.0 172.30.2.2 &lt;none&gt; Ubuntu 20.04.5 LTS 5.4.0-131-generic containerd://1.6.12 操作系统为：Ubuntu 22.04 lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.5 LTS Release: 20.04 Codename: focal 搭建 nfscontrolplane 节点操作apt install nfs-kernel-server -y mkdir -p /nfs/data chown nobody:nogroup /nfs/data echo &quot;/nfs/data/ *(rw,sync,no_subtree_check)&quot; &gt; /etc/exports systemctl restart nfs-kernel-server node01 节点操作apt install nfs-common -y showmount -e 172.30.1.2 mkdir -p /nfs/data mount 172.30.1.2:/nfs/data /nfs/data 设置存储类apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: nfs-storage annotations: storageclass.kubernetes.io/is-default-class: &quot;true&quot; provisioner: k8s-sigs.io/nfs-subdir-external-provisioner parameters: archiveOnDelete: &quot;true&quot; ## 删除 pv 的时候，pv 的内容是否要备份 --- apiVersion: apps/v1 kind: Deployment metadata: name: nfs-client-provisioner labels: app: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default spec: replicas: 1 strategy: type: Recreate selector: matchLabels: app: nfs-client-provisioner template: metadata: labels: app: nfs-client-provisioner spec: serviceAccountName: nfs-client-provisioner containers: - name: nfs-client-provisioner image: registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/nfs-subdir-external-provisioner:v4.0.2 # resources: # limits: # cpu: 10m # requests: # cpu: 10m volumeMounts: - name: nfs-client-root mountPath: /persistentvolumes env: - name: PROVISIONER_NAME value: k8s-sigs.io/nfs-subdir-external-provisioner - name: NFS_SERVER value: 172.30.1.2 ## 指定自己 nfs 服务器地址 - name: NFS_PATH value: /nfs/data ## nfs 服务器共享的目录 volumes: - name: nfs-client-root nfs: server: 172.30.1.2 path: /nfs/data --- apiVersion: v1 kind: ServiceAccount metadata: name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default --- kind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1 metadata: name: nfs-client-provisioner-runner rules: - apiGroups: [&quot;&quot;] resources: [&quot;nodes&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;] - apiGroups: [&quot;&quot;] resources: [&quot;persistentvolumes&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;delete&quot;] - apiGroups: [&quot;&quot;] resources: [&quot;persistentvolumeclaims&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;] - apiGroups: [&quot;storage.k8s.io&quot;] resources: [&quot;storageclasses&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;] - apiGroups: [&quot;&quot;] resources: [&quot;events&quot;] verbs: [&quot;create&quot;, &quot;update&quot;, &quot;patch&quot;] --- kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: run-nfs-client-provisioner subjects: - kind: ServiceAccount name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default roleRef: kind: ClusterRole name: nfs-client-provisioner-runner apiGroup: rbac.authorization.k8s.io --- kind: Role apiVersion: rbac.authorization.k8s.io/v1 metadata: name: leader-locking-nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default rules: - apiGroups: [&quot;&quot;] resources: [&quot;endpoints&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;] --- kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1 metadata: name: leader-locking-nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default subjects: - kind: ServiceAccount name: nfs-client-provisioner # replace with namespace where provisioner is deployed namespace: default roleRef: kind: Role name: leader-locking-nfs-client-provisioner apiGroup: rbac.authorization.k8s.io 检查结果kubectl get sc NAME PROVISIONER RECLAIMPOLICY VOLUMEBINDINGMODE ALLOWVOLUMEEXPANSION AGE nfs-storage (default) k8s-sigs.io/nfs-subdir-external-provisioner Delete Immediate false 2s","categories":[{"name":"云原生","slug":"云原生","permalink":"https://xwls.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://xwls.github.io/tags/k8s/"}]},{"title":"git 统计代码量","slug":"git-statistics","date":"2023-01-05T02:52:52.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2023/01/05/git-statistics/","link":"","permalink":"https://xwls.github.io/2023/01/05/git-statistics/","excerpt":"根据 git 提交记录统计制定提交人指定时间范围的代码量。","text":"根据 git 提交记录统计制定提交人指定时间范围的代码量。 指定提交人的代码量git log --author=&quot;Kevin Wan&quot; --pretty=tformat: --numstat | awk &#39;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc &#125;&#39; - 执行结果 added lines: 42392, removed lines: 28107, total lines: 14285 所有提交人的代码量git log --format=&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#39;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc &#125;&#39; -; done 执行结果 ALMAS added lines: 1, removed lines: 1, total lines: 0 Allen Liu added lines: 2, removed lines: 2, total lines: 0 Amor added lines: 80, removed lines: 1, total lines: 79 Archer added lines: 50, removed lines: 7, total lines: 43 Atlan added lines: 4, removed lines: 2, total lines: 2 BYT0723 added lines: 2, removed lines: 2, total lines: 0 Bo-Yi Wu added lines: 437, removed lines: 461, total lines: -24 指定时间范围git log --author=&quot;Kevin Wan&quot; --since=2022-12-01 --until=2022-12-31 --pretty=tformat: --numstat | awk &#39;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc &#125;&#39; - 执行结果 added lines: 1868, removed lines: 923, total lines: 945 提交者排名前 5git log --pretty=&#39;%aN&#39; | sort | uniq -c | sort -k1 -n -r | head -n 5 执行结果 737 Kevin Wan 356 kevin 112 anqiansong 71 kingxt 39 dependabot[bot] git log 参数说明--author 指定作者 --stat 显示每次更新的文件修改统计信息，会列出具体文件列表 --shortstat 统计每个 commit 的文件修改行数，包括增加，删除，但不列出文件列表： --numstat 统计每个 commit 的文件修改行数，包括增加，删除，并列出文件列表： -p 选项展开显示每次提交的内容差异，用-2 则仅显示最近的两次更新，例如：git log -p -2 --name-only 仅在提交信息后显示已修改的文件清单 --name-status 显示新增、修改、删除的文件清单 --abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符 --relative-date 使用较短的相对时间显示（比如，“2 weeks ago”） --graph 显示 ASCII 图形表示的分支合并历史 --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）, 例如： git log --pretty=oneline ; git log --pretty=short ; git log --pretty=full ; git log --pretty=fuller --pretty=tformat: 可以定制要显示的记录格式，这样的输出便于后期编程提取分析 例如：git log --pretty=format:&quot;&quot;%h - %an, %ar : %s&quot;&quot; 下面列出了常用的格式占位符写法及其代表的意义。 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者 (committer) 的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 --since 限制显示输出的范围， 例如： git log --since=2.weeks 显示最近两周的提交 选项 说明 -(n) 仅显示最近的 n 条提交 --since, --after 仅显示指定时间之后的提交。 --until, --before 仅显示指定时间之前的提交。 --author 仅显示指定作者相关的提交。 --committer 仅显示指定提交者相关的提交。","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://xwls.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://xwls.github.io/tags/git/"}]},{"title":"MacOS 使用 minikube 搭建 Kubernetes 环境","slug":"macos-minikube-k8s","date":"2022-10-19T08:14:16.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/10/19/macos-minikube-k8s/","link":"","permalink":"https://xwls.github.io/2022/10/19/macos-minikube-k8s/","excerpt":"MacOS 使用 minikube 搭建 Kubernetes 环境。","text":"MacOS 使用 minikube 搭建 Kubernetes 环境。 在 MacOS 下，使用 minikube 搭建 Kubernetes 环境，遇到了大量的问题，包括 [kubelet-check] Initial timeout of 40s passed.、拉取镜像失败、dashboard 启动失败，等等。 安装 minikube minikube 官网：https://minikube.sigs.k8s.io/docs/start/ 安装时最开始使用的是 brew 进行安装，brew 安装有个问题，会默认安装依赖项 kubernetes-cli，安装的版本比较新，会有奇奇怪怪的问题导致初始化时报错，后来删除 brew 安装的 minikube 和 kubernetes-cli，使用 binary 安装。 curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-darwin-amd64 sudo install minikube-darwin-amd64 /usr/local/bin/minikube 启动 minikube 启动失败解决：https://www.jeeinn.com/2022/07/1715/ 启动时可以使用--image-mirror-country=&#39;cn&#39;指定镜像为中国镜像，这样拉取镜像会快很多，顺便使用--kubernetes-version=v1.23.8指定版本。 minikube start --image-mirror-country=&#39;cn&#39; --kubernetes-version=v1.23.8 测试minikube kubectl -- get po -A 解决镜像拉取失败的问题 解决方案：https://blog.csdn.net/w757227129/article/details/123512692 使用minikube ssh进入 minikube 的 docker 节点 执行 touch &#x2F;etc&#x2F;docker&#x2F;daemon.json 将以下配置添加到 daemon.json 文件中 &#123; &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn/&quot;] &#125; 然后重启 minikube 再次运行 kubectl create 创建资源的时候，镜像会被成功拉取","categories":[{"name":"云原生","slug":"云原生","permalink":"https://xwls.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://xwls.github.io/tags/docker/"},{"name":"k8s","slug":"k8s","permalink":"https://xwls.github.io/tags/k8s/"},{"name":"mac","slug":"mac","permalink":"https://xwls.github.io/tags/mac/"}]},{"title":"Docker 搭建 Redis 集群","slug":"docker-redis-cluster","date":"2022-10-18T08:15:27.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/10/18/docker-redis-cluster/","link":"","permalink":"https://xwls.github.io/2022/10/18/docker-redis-cluster/","excerpt":"使用 docker 创建 redis 集群。","text":"使用 docker 创建 redis 集群。 拉取 redis 镜像docker pull redis 创建 redis 配置文件for port in $(seq 6379 6384); do mkdir -p /home/redis/node-$&#123;port&#125;/conf touch /home/redis/node-$&#123;port&#125;/conf/redis.conf cat &lt;&lt; EOF &gt; /home/redis/node-$&#123;port&#125;/conf/redis.conf port $&#123;port&#125; requirepass 1234 bind 0.0.0.0 protected-mode no daemonize no appendonly yes cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 服务器就填公网 ip，或者内部对应容器的 ip cluster-announce-port $&#123;port&#125; cluster-announce-bus-port 1$&#123;port&#125; EOF done 效果 [root@iZuf6brvjzmnf06szlrk7oZ ~]# cd /home/redis/ [root@iZuf6brvjzmnf06szlrk7oZ redis]# tree . ├── node-6379 │ └── conf │ └── redis.conf ├── node-6380 │ └── conf │ └── redis.conf ├── node-6381 │ └── conf │ └── redis.conf ├── node-6382 │ └── conf │ └── redis.conf ├── node-6383 │ └── conf │ └── redis.conf └── node-6384 └── conf └── redis.conf 12 directories, 6 files 启动 redisfor port in $(seq 6379 6384); \\ do \\ docker run -it -d -p $&#123;port&#125;:$&#123;port&#125; -p 1$&#123;port&#125;:1$&#123;port&#125; \\ --privileged=true -v /home/redis/node-$&#123;port&#125;/conf/redis.conf:/usr/local/etc/redis/redis.conf \\ --privileged=true -v /home/redis/node-$&#123;port&#125;/data:/data \\ --restart always --name redis-$&#123;port&#125; --net myredis \\ --sysctl net.core.somaxconn=1024 redis redis-server /usr/local/etc/redis/redis.conf done 效果 [root@iZuf6brvjzmnf06szlrk7oZ redis]# for port in $(seq 6379 6384); \\ &gt; do \\ &gt; docker run -it -d -p $&#123;port&#125;:$&#123;port&#125; -p 1$&#123;port&#125;:1$&#123;port&#125; \\ &gt; --privileged=true -v /home/redis/node-$&#123;port&#125;/conf/redis.conf:/usr/local/etc/redis/redis.conf \\ &gt; --privileged=true -v /home/redis/node-$&#123;port&#125;/data:/data \\ &gt; --restart always --name redis-$&#123;port&#125; --net myredis \\ &gt; --sysctl net.core.somaxconn=1024 redis redis-server /usr/local/etc/redis/redis.conf &gt; done c456167625319a7177036b09d516ff0813a31d61dbb24273ce1d1ff041f3f621 3fc3c14204e9c9b2e80211f13c68a8cc8e1ee65c26683078453ec2052f0b6b53 b04bb20f74e5e418e5588f1cc67e5aaf1a66e210f86f7ee1b433c489b157da0b 5a501f0f18a9891246aa70cfc0f770f6e311ad6888004cb46e59f24185f59991 13d7a9dcdc44d74592b25c12ea8e5d204bbd25200231f8fe9a55e5eac7803326 ad3e265183d8815e29d19d488bb357d6fb931949eda46dbfc95018b32e51cf85 创建集群# 进入容器 bash docker exec -it redis-6379 /bin/bash # 创建集群 redis-cli -a 1234 --cluster create 47.103.58.89:6379 47.103.58.89:6380 47.103.58.89:6381 47.103.58.89:6382 47.103.58.89:6383 47.103.58.89:6384 --cluster-replicas 1 效果 [root@iZuf6brvjzmnf06szlrk7oZ redis]# docker exec -it redis-6379 /bin/bash root@c45616762531:/data# redis-cli -a 1234 --cluster create 47.103.58.89:6379 47.103.58.89:6380 47.103.58.89:6381 47.103.58.89:6382 47.103.58.89:6383 47.103.58.89:6384 --cluster-replicas 1 Warning: Using a password with &#39;-a&#39; or &#39;-u&#39; option on the command line interface may not be safe. &gt;&gt;&gt; Performing hash slots allocation on 6 nodes... Master[0] -&gt; Slots 0 - 5460 Master[1] -&gt; Slots 5461 - 10922 Master[2] -&gt; Slots 10923 - 16383 Adding replica 47.103.58.89:6383 to 47.103.58.89:6379 Adding replica 47.103.58.89:6384 to 47.103.58.89:6380 Adding replica 47.103.58.89:6382 to 47.103.58.89:6381 &gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity [WARNING] Some slaves are in the same host as their master M: 3d1df32edcb46e9d2f0e9c6b4b0c68baf99ca32d 47.103.58.89:6379 slots:[0-5460] (5461 slots) master M: 8e833d82ff85892646552e4cfda9f5d024ce7dc9 47.103.58.89:6380 slots:[5461-10922] (5462 slots) master M: 535cd50270c353ca0e9196e09203d846788cf67a 47.103.58.89:6381 slots:[10923-16383] (5461 slots) master S: af331e16ecd61119e6b627fbd27590f3ffaae26a 47.103.58.89:6382 replicates 3d1df32edcb46e9d2f0e9c6b4b0c68baf99ca32d S: 34067385c2b8152575b83428d0cdcb50e1b837d5 47.103.58.89:6383 replicates 8e833d82ff85892646552e4cfda9f5d024ce7dc9 S: fdca52748b918280deaa05bce48a214f4a365041 47.103.58.89:6384 replicates 535cd50270c353ca0e9196e09203d846788cf67a Can I set the above configuration? (type &#39;yes&#39; to accept): yes &gt;&gt;&gt; Nodes configuration updated &gt;&gt;&gt; Assign a different config epoch to each node &gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join .. &gt;&gt;&gt; Performing Cluster Check (using node 47.103.58.89:6379) M: 3d1df32edcb46e9d2f0e9c6b4b0c68baf99ca32d 47.103.58.89:6379 slots:[0-5460] (5461 slots) master 1 additional replica(s) S: af331e16ecd61119e6b627fbd27590f3ffaae26a 47.103.58.89:6382 slots: (0 slots) slave replicates 3d1df32edcb46e9d2f0e9c6b4b0c68baf99ca32d S: fdca52748b918280deaa05bce48a214f4a365041 47.103.58.89:6384 slots: (0 slots) slave replicates 535cd50270c353ca0e9196e09203d846788cf67a S: 34067385c2b8152575b83428d0cdcb50e1b837d5 47.103.58.89:6383 slots: (0 slots) slave replicates 8e833d82ff85892646552e4cfda9f5d024ce7dc9 M: 535cd50270c353ca0e9196e09203d846788cf67a 47.103.58.89:6381 slots:[10923-16383] (5461 slots) master 1 additional replica(s) M: 8e833d82ff85892646552e4cfda9f5d024ce7dc9 47.103.58.89:6380 slots:[5461-10922] (5462 slots) master 1 additional replica(s) [OK] All nodes agree about slots configuration. &gt;&gt;&gt; Check for open slots... &gt;&gt;&gt; Check slots coverage... [OK] All 16384 slots covered. 查看集群信息# 连接 redis redis-cli -c -a 1234 # 查看集群信息 CLUSTER INFO # 查看节点信息 CLUSTER NODES 效果 127.0.0.1:6379&gt; CLUSTER INFO cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:6 cluster_my_epoch:1 cluster_stats_messages_ping_sent:81 cluster_stats_messages_pong_sent:90 cluster_stats_messages_sent:171 cluster_stats_messages_ping_received:85 cluster_stats_messages_pong_received:79 cluster_stats_messages_meet_received:5 cluster_stats_messages_received:169 total_cluster_links_buffer_limit_exceeded:0 127.0.0.1:6379&gt; CLUSTER NODES af331e16ecd61119e6b627fbd27590f3ffaae26a 47.103.58.89:6382@16382 slave 3d1df32edcb46e9d2f0e9c6b4b0c68baf99ca32d 0 1666080700700 1 connected 3d1df32edcb46e9d2f0e9c6b4b0c68baf99ca32d 47.103.58.89:6379@16379 myself,master - 0 1666080699000 1 connected 0-5460 fdca52748b918280deaa05bce48a214f4a365041 47.103.58.89:6384@16384 slave 535cd50270c353ca0e9196e09203d846788cf67a 0 1666080700000 3 connected 34067385c2b8152575b83428d0cdcb50e1b837d5 47.103.58.89:6383@16383 slave 8e833d82ff85892646552e4cfda9f5d024ce7dc9 0 1666080700820 2 connected 535cd50270c353ca0e9196e09203d846788cf67a 47.103.58.89:6381@16381 master - 0 1666080700644 3 connected 10923-16383 8e833d82ff85892646552e4cfda9f5d024ce7dc9 47.103.58.89:6380@16380 master - 0 1666080699697 2 connected 5461-10922","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://xwls.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://xwls.github.io/tags/docker/"},{"name":"redis","slug":"redis","permalink":"https://xwls.github.io/tags/redis/"},{"name":"集群","slug":"集群","permalink":"https://xwls.github.io/tags/%E9%9B%86%E7%BE%A4/"}]},{"title":"MyBatis 调用数据库存储过程","slug":"mybatis-call-procedure","date":"2022-10-17T06:19:13.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/10/17/mybatis-call-procedure/","link":"","permalink":"https://xwls.github.io/2022/10/17/mybatis-call-procedure/","excerpt":"使用 MyBatis 调用数据库的存储过程。","text":"使用 MyBatis 调用数据库的存储过程。 项目中有个需求：调用数据库中已有的存储过程实现用户登录业务，此存储过程接收 3 个参数，两个入参：username&#x2F;password，一个出参：result，登录成功 result 为 1，失败为 0。 创建存储过程这里简单创建一个存储过程，模拟登录，当用户名不为空且密码为 123456，则认为登录成功，否则认为登录失败。 create or replace procedure login_wzw(username in varchar2,password in varchar2, result out int) as begin if username is null or username = &#39;&#39; then select 0 into result from dual; return ; end if; if password = &#39;123456&#39; then select 1 into result from dual; else select 0 into result from dual; end if; end; 测试存储过程 测试用户名为空，输出：result&#x3D;0 declare username varchar2(100); password varchar2(100); result int; begin username := &#39;&#39;; password := &#39;123456&#39;; login_wzw(username, password, result); dbms_output.put_line(&#39;result=&#39;||result); end; 测试密码错误，输出：result&#x3D;0 declare username varchar2(100); password varchar2(100); result int; begin username := &#39;zhangsan&#39;; password := &#39;1234567&#39;; login_wzw(username, password, result); dbms_output.put_line(&#39;result=&#39;||result); end; 测试密码正确，输出：result&#x3D;1 declare username varchar2(100); password varchar2(100); result int; begin username := &#39;zhangsan&#39;; password := &#39;123456&#39;; login_wzw(username, password, result); dbms_output.put_line(&#39;result=&#39;||result); end; MyBatis 调用使用 MyBatis 调用存储过程。 参数为实体类 UserLogin.java public class UserLogin &#123; private String username; private String password; private Integer result; //省略 setter/getter &#125; Mapper.java void loginWzw(UserLogin userLogin); Mapper.xml &lt;select id=&quot;loginWzw&quot; statementType=&quot;CALLABLE&quot; useCache=&quot;false&quot;&gt; &#123;call LOGIN_WZW( #&#123;username,jdbcType=VARCHAR,mode=IN&#125;, #&#123;password,jdbcType=VARCHAR,mode=IN&#125;, #&#123;result,jdbcType=INTEGER,mode=OUT&#125; )&#125; &lt;/select&gt; 执行结果： ProcedureLoginVo&#123;username=&#39;admin&#39;, password=&#39;123456&#39;, result=null&#125; 13:54:37.307 [main] DEBUG c.r.p.s.m.S.loginWzw - [debug,137] - ==&gt; Preparing: &#123;call LOGIN_WZW( ?, ?, ? )&#125; 13:54:37.318 [main] DEBUG c.r.p.s.m.S.loginWzw - [debug,137] - ==&gt; Parameters: admin(String), 123456(String) ProcedureLoginVo&#123;username=&#39;admin&#39;, password=&#39;123456&#39;, result=1&#125; 参数为 Map Mapper.java void loginWzw2(Map&lt;String,Object&gt; param); Mapper.xml &lt;select id=&quot;loginWzw2&quot; statementType=&quot;CALLABLE&quot; parameterType=&quot;map&quot; useCache=&quot;false&quot;&gt; &#123;call LOGIN_WZW( #&#123;username,jdbcType=VARCHAR,mode=IN&#125;, #&#123;password,jdbcType=VARCHAR,mode=IN&#125;, #&#123;result,jdbcType=INTEGER,mode=OUT&#125; )&#125; &lt;/select&gt; 执行结果 &#123;password=1234567, username=admin&#125; 13:54:37.335 [main] DEBUG c.r.p.s.m.S.loginWzw2 - [debug,137] - ==&gt; Preparing: &#123;call LOGIN_WZW( ?, ?, ? )&#125; 13:54:37.335 [main] DEBUG c.r.p.s.m.S.loginWzw2 - [debug,137] - ==&gt; Parameters: admin(String), 1234567(String) &#123;result=0, password=1234567, username=admin&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xwls.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xwls.github.io/tags/java/"},{"name":"数据库","slug":"数据库","permalink":"https://xwls.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"存储过程","slug":"存储过程","permalink":"https://xwls.github.io/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"},{"name":"mybatis","slug":"mybatis","permalink":"https://xwls.github.io/tags/mybatis/"}]},{"title":"ArrayList 扩容规则","slug":"array-list-incr-capacity","date":"2022-10-15T07:28:59.000Z","updated":"2023-08-18T03:56:18.114Z","comments":true,"path":"2022/10/15/array-list-incr-capacity/","link":"","permalink":"https://xwls.github.io/2022/10/15/array-list-incr-capacity/","excerpt":"Java 中的常用集合类 ArrayList 的扩容规则。","text":"Java 中的常用集合类 ArrayList 的扩容规则。 验证程序import java.lang.reflect.Field; import java.util.ArrayList; class Scratch &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; printInfo(list); list.add(String.valueOf(i)); &#125; &#125; /** * 打印 ArrayList 的大小和容量 */ private static void printInfo(ArrayList&lt;?&gt; list) &#123; Class&lt;?&gt; aClass = list.getClass(); Field elementData = null; try &#123; // 获取 ArrayList 中用来存储元素的数组 elementData = aClass.getDeclaredField(&quot;elementData&quot;); &#125; catch (NoSuchFieldException e) &#123; throw new RuntimeException(e); &#125; elementData.setAccessible(true); Object[] o; try &#123; o = (Object[]) elementData.get(list); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; // 输出当前大小和容量 System.out.println(&quot;size = &quot; + list.size() + &quot;, capacity = &quot; + o.length); &#125; &#125; 执行结果size = 0, capacity = 0 size = 1, capacity = 10 size = 2, capacity = 10 size = 3, capacity = 10 size = 4, capacity = 10 size = 5, capacity = 10 size = 6, capacity = 10 size = 7, capacity = 10 size = 8, capacity = 10 size = 9, capacity = 10 size = 10, capacity = 10 size = 11, capacity = 15 size = 12, capacity = 15 size = 13, capacity = 15 size = 14, capacity = 15 size = 15, capacity = 15 size = 16, capacity = 22 size = 17, capacity = 22 size = 18, capacity = 22 size = 19, capacity = 22 size = 20, capacity = 22 size = 21, capacity = 22 size = 22, capacity = 22 size = 23, capacity = 33 size = 24, capacity = 33 size = 25, capacity = 33 size = 26, capacity = 33 size = 27, capacity = 33 size = 28, capacity = 33 size = 29, capacity = 33 size = 30, capacity = 33 size = 31, capacity = 33 size = 32, capacity = 33 size = 33, capacity = 33 size = 34, capacity = 49 size = 35, capacity = 49 size = 36, capacity = 49 size = 37, capacity = 49 size = 38, capacity = 49 size = 39, capacity = 49 size = 40, capacity = 49 size = 41, capacity = 49 size = 42, capacity = 49 size = 43, capacity = 49 size = 44, capacity = 49 size = 45, capacity = 49 size = 46, capacity = 49 size = 47, capacity = 49 size = 48, capacity = 49 size = 49, capacity = 49 size = 50, capacity = 73 size = 51, capacity = 73 size = 52, capacity = 73 size = 53, capacity = 73 size = 54, capacity = 73 size = 55, capacity = 73 size = 56, capacity = 73 size = 57, capacity = 73 size = 58, capacity = 73 size = 59, capacity = 73 size = 60, capacity = 73 size = 61, capacity = 73 size = 62, capacity = 73 size = 63, capacity = 73 size = 64, capacity = 73 size = 65, capacity = 73 size = 66, capacity = 73 size = 67, capacity = 73 size = 68, capacity = 73 size = 69, capacity = 73 size = 70, capacity = 73 size = 71, capacity = 73 size = 72, capacity = 73 size = 73, capacity = 73 size = 74, capacity = 109 size = 75, capacity = 109 size = 76, capacity = 109 size = 77, capacity = 109 size = 78, capacity = 109 size = 79, capacity = 109 size = 80, capacity = 109 size = 81, capacity = 109 size = 82, capacity = 109 size = 83, capacity = 109 size = 84, capacity = 109 size = 85, capacity = 109 size = 86, capacity = 109 size = 87, capacity = 109 size = 88, capacity = 109 size = 89, capacity = 109 size = 90, capacity = 109 size = 91, capacity = 109 size = 92, capacity = 109 size = 93, capacity = 109 size = 94, capacity = 109 size = 95, capacity = 109 size = 96, capacity = 109 size = 97, capacity = 109 size = 98, capacity = 109 size = 99, capacity = 109 结论 刚创建未添加任何元素时，容量是 0。 当添加第一个元素时，容量为默认容量 10。 需要扩容时，容量会变为原先的 1.5 倍。","categories":[{"name":"Java","slug":"Java","permalink":"https://xwls.github.io/categories/Java/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://xwls.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"算法","slug":"算法","permalink":"https://xwls.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"MacOS 安装 Hadoop 3.3.4","slug":"macos-install-hadoop-334","date":"2022-10-15T06:17:04.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/10/15/macos-install-hadoop-334/","link":"","permalink":"https://xwls.github.io/2022/10/15/macos-install-hadoop-334/","excerpt":"MacOS 12.6 安装 Hadoop 3.3.4 单机版","text":"MacOS 12.6 安装 Hadoop 3.3.4 单机版 下载 Hadoop 官网：https://hadoop.apache.org 下载：https://dlcdn.apache.org/hadoop/common/hadoop-3.3.4/ 配置 创建目录用来存放Hadoop mkdir -p /Users/wangzengwei/Tools/hadoop-3.3.4 解压缩下载好的Hadoop文件 cd /Users/wangzengwei/Tools/hadoop-3.3.4 tar -zxvf hadoop-3.3.4.tar.gz 配置 hadoop-env.sh export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_341.jdk/Contents/Home export HADOOP_CONF_DIR=/Users/wangzengwei/Tools/hadoop-3.3.4/etc/hadoop 配置 core-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;!--用来指定hadoop运行时产生文件的存放目录 自己创建--&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/Users/wangzengwei/Tools/hadoop-3.3.4/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.trash.interval&lt;/name&gt; &lt;value&gt;1440&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 配置 hdfs-site.xml &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;!--不是root用户也可以写文件到hdfs--&gt; &lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;!--关闭防火墙--&gt; &lt;/property&gt; &lt;!--把路径换成本地的name坐在位置--&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/Users/wangzengwei/Tools/hadoop-3.3.4/namenodedir&lt;/value&gt; &lt;/property&gt; &lt;!--在本地新建一个存放hadoop数据的文件夹，然后将路径在这里配置一下--&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/Users/wangzengwei/Tools/hadoop-3.3.4/datanodedir&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 配置 mapred-site.xml &lt;configuration&gt; &lt;property&gt; &lt;!--指定mapreduce运行在yarn上--&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 配置 yarn-site.xml &lt;configuration&gt; &lt;!-- Site specific YARN configuration properties --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;localhost:18040&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;localhost:18030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;localhost:18025&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;localhost:18141&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;localhost:18088&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; Hadoop namenode 格式化 hdfs namenode -format 配置 ssh 免密登录 ssh-keygen -t rsa cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys # 验证ssh ssh localhost 启动cd /Users/wangzengwei/Tools/hadoop-3.3.4/sbin ./start-all.sh 验证终端执行 jps 命令，在打印结果中会看到 5 个进程，分别是 namenode、 secondarynamenode、datanode、resourcemanager、nodemanager，说明启动成功 浏览器访问：http://localhost:18088，查看Hadoop集群信息 浏览器访问：http://localhost:9870，查看HDFS信息 停止cd /Users/wangzengwei/Tools/hadoop-3.3.4/sbin ./stop-all.sh","categories":[{"name":"大数据","slug":"大数据","permalink":"https://xwls.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://xwls.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"大数据","slug":"大数据","permalink":"https://xwls.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://xwls.github.io/tags/Hadoop/"},{"name":"Mac","slug":"Mac","permalink":"https://xwls.github.io/tags/Mac/"}]},{"title":"CentOS8 安装 Docker CE","slug":"centos8-install-docker-ce","date":"2022-10-15T01:56:28.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/10/15/centos8-install-docker-ce/","link":"","permalink":"https://xwls.github.io/2022/10/15/centos8-install-docker-ce/","excerpt":"本步骤指导您如何在 ECS 实例上部署 Docker","text":"本步骤指导您如何在 ECS 实例上部署 Docker 执行如下命令，安装 dnf。dnf 是新一代的 rpm 软件包管理器。 yum -y install dnf 执行如下命令，安装 Docker 存储驱动的依赖包。 dnf install -y device-mapper-persistent-data lvm2 执行如下命令，添加稳定的 Docker 软件源。 yum makecache fast yum -y install docker-ce 执行如下命令，查看已添加的 Docker 软件源。 dnf list docker-ce 执行如下命令，安装 docker-ce。 dnf install -y docker-ce --nobest 执行如下命令，启动 Docker 服务。 systemctl start docker 执行如下命令，查看 Docker 服务的运行状态。 systemctl status docker 返回结果如下，表示 Docker 服务处于运行中的状态。按 q 键退出查看 Docker 服务的运行状态。 执行如下命令，查看 Docker 的版本。 docker -v 返回结果如下，您可查看到 Docker 的版本。","categories":[{"name":"云原生","slug":"云原生","permalink":"https://xwls.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://xwls.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"centos","slug":"centos","permalink":"https://xwls.github.io/tags/centos/"},{"name":"linux","slug":"linux","permalink":"https://xwls.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://xwls.github.io/tags/docker/"}]},{"title":"Git 全局忽略 .DS_Store 文件","slug":"git-global-ingore","date":"2022-08-29T08:29:36.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/08/29/git-global-ingore/","link":"","permalink":"https://xwls.github.io/2022/08/29/git-global-ingore/","excerpt":"Git 全局忽略指定文件，以 MacOS 的 .DS_Store 文件为例","text":"Git 全局忽略指定文件，以 MacOS 的 .DS_Store 文件为例 .DS_Store 文件DS_Store，英文全称是 Desktop Services Store（桌面服务存储），开头的 DS 是 Desktop Services（桌面服务） 的缩写。它是一种由 macOS 系统自动创建的隐藏文件，存在于每一个用「访达」打开过的文件夹下面。 虽然不能在「访达」中直接看到它，但是通过「终端」App，可以输入ls -la命令列出。同时，通过file命令，可以显示出其文件类型，即”Desktop Services Store“。 DS_Store 文件的主要作用，是存储当前文件夹在桌面显示相关方面的一些自定义属性，包括文件图标的位置、文件夹上次打开时窗口的大小、展现形式和位置等。这有助于保留为特定文件夹配置的设置，例如，将桌面文件夹设置为查看按名称排序的图标，同时将下载文件夹配置为将文件显示为列表并按日期排序，最近修改的先显示。 Git 忽略 .DS_Store 文件作为一名使用 Mac 的开发者，在日常开发过程中，经常会使用 Git 来对代码文件夹进行版本控制。而在默认情况下，Git 会把 .DS_Store 文件带入版本控制的范围内。所以，可以手动将其踏入 Git 的版本管理忽略列表。 将 .DS_Store 加入全局的 .gitignore 文件，执行命令： echo .DS_Store &gt;&gt; ~/.gitignore_global 将这个全局的 .gitignore 文件加入 Git 的全局 config 文件中，执行命令： git config --global core.excludesfile ~/.gitignore_global","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://xwls.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://xwls.github.io/tags/git/"}]},{"title":"ORA-01502: 索引 'xxx' 或这类索引的分区处于不可用状态","slug":"ora-01502-index-unavailable","date":"2022-08-25T08:13:07.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/08/25/ora-01502-index-unavailable/","link":"","permalink":"https://xwls.github.io/2022/08/25/ora-01502-index-unavailable/","excerpt":"ORA-01502: 索引 ‘xxx’ 或这类索引的分区处于不可用状态，移动表空间后，导致索引失效，处于不可用状态。","text":"ORA-01502: 索引 ‘xxx’ 或这类索引的分区处于不可用状态，移动表空间后，导致索引失效，处于不可用状态。 ### The error occurred while setting parameters ### SQL: insert into USER_LBL_INF( LBL_ID,LBL_NM,USERID,CRT_TM) values( ?, ? , ? , ? ) ### Cause: java.sql.SQLException: ORA-01502: 索引 &#39;BASE_PD.PK_USER_LBL_INF&#39; 或这类索引的分区处于不可用状态 ; uncategorized SQLException; SQL state [72000]; error code [1502]; ORA-01502: 索引 &#39;BASE_PD.PK_USER_LBL_INF&#39; 或这类索引的分区处于不可用状态 ; nested exception is java.sql.SQLException: ORA-01502: 索引 &#39;BASE_PD.PK_USER_LBL_INF&#39; 或这类索引的分区处于不可用状态 ] with root cause java.sql.SQLException: ORA-01502: 索引 &#39;BASE_PD.PK_USER_LBL_INF&#39; 或这类索引的分区处于不可用状态 查询不可用的索引SELECT INDEX_NAME, STATUS FROM DBA_INDEXES WHERE OWNER = &#39;RZGWL_WLLH&#39; AND STATUS != &#39;VALID&#39;; 重建索引ALTER INDEX PK_BT_RY_SYS_USER_ROLE REBUILD;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xwls.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://xwls.github.io/tags/oracle/"}]},{"title":"修改 Oracle 数据库的字符集","slug":"oracle-change-charset","date":"2022-08-25T08:09:14.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/08/25/oracle-change-charset/","link":"","permalink":"https://xwls.github.io/2022/08/25/oracle-change-charset/","excerpt":"修改 Oracle 数据库的字符集，项目中遇到的问题，客户的 Oracle 字符集是 ZHS16GBK，我们是 UTF8，需要将 UTF8 修改为 ZHS16GBK。","text":"修改 Oracle 数据库的字符集，项目中遇到的问题，客户的 Oracle 字符集是 ZHS16GBK，我们是 UTF8，需要将 UTF8 修改为 ZHS16GBK。 库 A 的编码为 gbk，库 B 的编码为 utf-8，两种编码格式下，汉字占的字节数不一样，gbk 为 2 个字节，utf-8 为 3 个字节。所有针对某些情况，需要修改字符集编码。 修改 Oracle 数据库的字符集（UTF8→ZHS16GBK）步骤如下： 1. 登录以 sysdba 的身份登录上去 conn sys/root as sysdba 2. 关闭数据库shutdown immediate; 3. 以 mount 打来数据库startup mount; 4. 设置 sessionALTER SYSTEM ENABLE RESTRICTED SESSION; ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0; ALTER SYSTEM SET AQ_TM_PROCESSES=0; 5. 启动数据库alter database open; 6. 修改字符集ALTER DATABASE character set INTERNAL_USE ZHS16GBK; 7. 关闭，重新启动shutdown immediate; startup; 8. 查看修改后的字符集SELECT * FROM V$NLS_PARAMETERS WHERE PARAMETER = &#39;NLS_CHARACTERSET&#39; ; select userenv(&#39;language&#39;) from dual; 当然字符集最好不要轻易修改，因为这会对数据库的数据有直接的影响，如果是正式环境的话，可能会造成不可估计的损失。修改完字符集后，数据库中已有的汉字将会出现乱码。请修改编码集前备份数据，修改完编码集后重新导入数据。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xwls.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://xwls.github.io/tags/oracle/"}]},{"title":"Oracle 表空间","slug":"oracle-tablespace","date":"2022-08-25T08:06:59.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/08/25/oracle-tablespace/","link":"","permalink":"https://xwls.github.io/2022/08/25/oracle-tablespace/","excerpt":"Oracle 数据库的表空间操作，包括：创建、修改、删除、查询","text":"Oracle 数据库的表空间操作，包括：创建、修改、删除、查询 创建-- 表空间类型及名称，默认不指定类型（永久） create [temporary | undo] tablespace &quot;TBS&quot; -- 数据文件的位置及大小 datafile &#39;D:\\Oracle\\TBS.dbf&#39; size 10m -- 是否自动扩展，默认 &#39;off&#39; [autoextend off] | [autoextend on next n maxsize m] -- 是否产生日志，默认 &#39;loggin&#39; [loggin | nologgin] -- 段空间自动管理，默认 &#39;auto&#39; 推荐 [segment space management auto] -- 表空间管理方式，dictionary | local(默认，推荐) [extent management local [uniform size n]] 例1：创建一个永久表空间 “TBS01”，其大小为 10MBcreate tablespace &quot;TBS01&quot; datafile &#39;D:\\Oracle\\TBS01.dbf&#39; size 10m; 1.路径必须存在，否则报错！2.表空间名称默认大写，除非用引号注明，如 “tbs” 则为小写 例2：创建一个自增表空间 “TBS02”，其大小为 10MB，每次扩展 1MB，最大扩展到 20MBcreate tablespace &quot;TBS02&quot; datafile &#39;D:\\Oracle\\TBS02.dbf&#39; size 10m autoextend on next 1m maxsize 20m; 查询上述表空间的情况：1M &#x3D; 1024KB，1KB &#x3D; 1024 Byte select t.tablespace_name, -- 表空间 t.file_name, -- 文件名 t.autoextensible, -- 是否自增 t.bytes / 1024 / 1024 &quot;SIZE(M)&quot;, -- 初始值 t.increment_by * 8 / 1024 &quot;NEXT(M)&quot;, -- 步长 1blok = 8KB t.maxbytes / 1024 / 1024 &quot;MAXSIZE(M)&quot; -- 最大值 from dba_data_files t where t.tablespace_name IN (&#39;TBS01&#39;,&#39;TBS02&#39;); 修改例1：修改数据文件的大小为 20Malter database datafile &#39;D:\\Oracle\\TBS01.dbf&#39; resize 20m; 例2：修改数据文件为自动扩展，最大值为 1Galter database datafile &#39;D:\\Oracle\\TBS01.dbf&#39; autoextend on next 20m maxsize 1g; 例3：新增数据文件alter tablespace &quot;TBS01&quot; add datafile &#39;D:\\Oracle\\TBS01_1.dbf&#39; size 200m; 删除例1：脱机（表空间为空）drop tablespace &quot;TBS&quot;; 例2：脱机（表空间里有数据）drop tablespace &quot;TBS&quot; including contents; 例3：完全删除（表空间 + 数据文件）drop tablespace &quot;TBS&quot; including contents and datafiles; 例4：若存在约束，则追加下列子句即可cascade constraints; 查询-- 数据文件 select * from dba_data_files; -- 表空间 select * from dba_tablespaces; select * from dba_free_space; -- 权限 select distinct t.privilege from dba_sys_privs t where t.privilege like &#39;%TABLESPACE%&#39;; 例1：查询表空间清单select ddf.tablespace_name 表空间名, ddf.file_name 数据文件名, ddf.file_id 数据文件id, ddf.autoextensible 是否自动扩展, ddf.bytes / 1024 / 1024 &quot;数据文件大小（M）&quot;, ddf.increment_by * 8 / 1024 &quot;自增步长（M）&quot;, round(ddf.maxbytes / 1021 / 1021) &quot;数据文件最大值（M）&quot;, dt.contents 表空间类型, dt.logging 是否生成日志, dt.extent_management 管理模式, dt.allocation_type 分配类型, dt.segment_space_management 段管理模式 from dba_data_files ddf, -- tablespace_name dba_tablespaces dt -- tablespace_name where dt.tablespace_name = ddf.tablespace_name order by ddf.file_id; 例2：表空间使用情况with temp_data_files as (select ddf.tablespace_name, sum(bytes) total from dba_data_files ddf group by ddf.tablespace_name), temp_free_space as (select dfs.tablespace_name, sum(bytes) free from dba_free_space dfs group by dfs.tablespace_name) select dt.tablespace_name 表空间名称, dt.contents 类型, (tdf.total / 1024 / 1024) &quot;总大小(M)&quot;, (tfs.free / 1024 / 1024) &quot;空闲(M)&quot;, round((tdf.total - tfs.free) / 1024 / 1024, 2) &quot;已使用(M)&quot;, round((tdf.total - tfs.free) / tdf.total * 100, 2) &quot;占比(%)&quot; from dba_tablespaces dt, -- tablespace_name temp_data_files tdf, -- tablespace_name temp_free_space tfs -- tablespace_name where tdf.tablespace_name = dt.tablespace_name and tfs.tablespace_name = dt.tablespace_name; 例3：创建用户并指定表空间-- 创建表空间 CREATE TABLESPACE WZW DATAFILE &#39;C:\\APP\\ORACLE\\ORADATA\\ORCL\\WZW.DBF&#39; SIZE 10m autoextend ON NEXT 10m maxsize 100m; -- 创建临时表空间 CREATE TEMPORARY TABLESPACE WZW_TMP TEMPFILE &#39;C:\\APP\\ORACLE\\ORADATA\\ORCL\\WZW_TMP.DBF&#39; SIZE 10m autoextend ON NEXT 10m maxsize 100M; -- 创建用户并指定表空间 CREATE USER WZW IDENTIFIED BY WZW DEFAULT tablespace WZW temporary tablespace WZW_TMP; -- 授权 GRANT CONNECT TO WZW; GRANT RESOURCE TO WZW;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://xwls.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://xwls.github.io/tags/oracle/"}]},{"title":"RabbitMQ 实现延迟消息","slug":"rabbitmq-delayed-message-exchange","date":"2022-07-15T08:02:35.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/07/15/rabbitmq-delayed-message-exchange/","link":"","permalink":"https://xwls.github.io/2022/07/15/rabbitmq-delayed-message-exchange/","excerpt":"RabbitMQ 实现延迟消息，rabbitmq_delayed_message_exchange 插件","text":"RabbitMQ 实现延迟消息，rabbitmq_delayed_message_exchange 插件 下载延时消息插件 插件首页：https://www.rabbitmq.com/community-plugins.html Github：https://github.com/rabbitmq/rabbitmq-delayed-message-exchange Github Releases：https://github.com/rabbitmq/rabbitmq-routing-node-stamp/releases 在 Docker 环境下，安装延迟消息插件进入容器找到 plugins 目录 docker exec -it rabbitmq bash ##可以看到，plugins 就是存放 mq 插件的地方了 ls 将插件复制到 plugins 目录下 cd /usr/etc/rabbitmq_plugins docker cp rabbitmq_delayed_message_exchange-3.8.0.ez rabbitmq:/plugins 回到 plugins 目录，查看 plugins 中是否有 rabbitmq_delayed_message_exchange 插件 激活插件 rabbitmq-plugins enable rabbitmq_delayed_message_exchange 重启 RabbitMQ docker restart rabbitmq 进入 RabbitMQ 管理界面查看插件是否成功生效 OK, 完成以上工作，就可以编写 Java 代码发送延迟消息了。 SpringBoot 中发送延迟消息Configpackage com.xjm.mid.compent.rabbitmq.config; import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.CustomExchange; import org.springframework.amqp.core.Queue; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.HashMap; import java.util.Map; /** * @author jaymin * 2020/09/22 */ @Configuration public class RabbitMQDelayedMessageConfig &#123; /** * 延迟消息交换机 */ public final static String DELAY_EXCHANGE = &quot;jaymin.delay.exchange&quot;; /** * 队列 */ public final static String DELAY_QUEUE = &quot;jaymin.delay.queue&quot;; /** * 路由 Key */ public final static String DELAY_ROUTING_KEY = &quot;jaymin.delay.routingKey&quot;; @Bean public CustomExchange delayMessageExchange() &#123; Map&lt;String, Object&gt; args = new HashMap&lt;&gt;(); args.put(&quot;x-delayed-type&quot;, &quot;direct&quot;); //自定义交换机 return new CustomExchange(DELAY_EXCHANGE, &quot;x-delayed-message&quot;, false, false, args); &#125; @Bean public Queue delayMessageQueue() &#123; return new Queue(DELAY_QUEUE, false, false, false); &#125; @Bean public Binding bindingDelayExchangeAndQueue() &#123; return BindingBuilder.bind(delayMessageQueue()).to(delayMessageExchange()).with(DELAY_ROUTING_KEY).noargs(); &#125; &#125; Clientpackage com.xjm.mid.compent.rabbitmq.web; import com.xjm.mid.compent.rabbitmq.config.RabbitMQDelayedMessageConfig; import com.xjm.mid.compent.rabbitmq.model.Letter; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.time.LocalDateTime; /** * @author jaymin * 2020/09/22 */ @RestController @RequestMapping(&quot;/message/delayed&quot;) @Slf4j public class DelayedMessageClient &#123; @Autowired private RabbitTemplate rabbitTemplate; @PostMapping(&quot;/ten&quot;) public void sendDelayedMessage1()&#123; Letter letter = new Letter(); letter.setRecipient(&quot;福尔摩斯&quot;); letter.setContext(&quot;您的 10S 外卖到了！&quot;); Integer ttl = 10000; rabbitTemplate.convertAndSend(RabbitMQDelayedMessageConfig.DELAY_EXCHANGE, RabbitMQDelayedMessageConfig.DELAY_ROUTING_KEY, letter, message -&gt; &#123; // 设置过期时间 message.getMessageProperties().setDelay(ttl); return message; &#125;); log.info(&quot;[发送时间] - [&#123;&#125;]-[过期时间]-[&#123;&#125;]&quot;, LocalDateTime.now(), ttl/1000); &#125; @PostMapping(&quot;/five&quot;) public void sendDelayedMessage2()&#123; Letter letter = new Letter(); letter.setRecipient(&quot;福尔摩斯&quot;); letter.setContext(&quot;您的 5S 外卖到了！&quot;); Integer ttl = 5000; rabbitTemplate.convertAndSend(RabbitMQDelayedMessageConfig.DELAY_EXCHANGE, RabbitMQDelayedMessageConfig.DELAY_ROUTING_KEY, letter, message -&gt; &#123; // 设置过期时间 message.getMessageProperties().setDelay(ttl); return message; &#125;); log.info(&quot;[发送时间] - [&#123;&#125;]-[过期时间]-[&#123;&#125;]&quot;, LocalDateTime.now(), ttl/1000); &#125; &#125; Listenerpackage com.xjm.mid.compent.rabbitmq.web; import com.rabbitmq.client.Channel; import com.xjm.mid.compent.rabbitmq.config.RabbitMQDelayedMessageConfig; import com.xjm.mid.compent.rabbitmq.model.Letter; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; import java.io.IOException; import java.time.LocalDateTime; /** * @author jaymin * 2020/09/22 */ @Component @Slf4j public class DelayMessageListener &#123; @RabbitListener(queues = &#123;RabbitMQDelayedMessageConfig.DELAY_QUEUE&#125;) @RabbitHandler public void receiveMessage(Channel channel, Message message, Letter letter) &#123; log.info(&quot;[listenerDelayQueue 监听的消息] - [消费时间] - [&#123;&#125;] - [&#123;&#125;]&quot;, LocalDateTime.now(), letter.toString()); &#125; &#125; Result rabbitmq 的延时插件极限时间是 8byte 长度 ms，大概 49 天。如果你的延时时间很长，建议配合定时任务进行处理。 message.getMessageProperties().setDelay(ttl); 这种方式设置延迟时间话，理论上最多 24 天左右。因为 setDelay() 的参数是 Integer 类型的，25 天的时候就超过了 Integer 的长度了，变成了负数，下游立马收到消息的。建议改为 message.getMessageProperties().getHeaders().put(&quot;x-delay&quot;,delay);","categories":[{"name":"中间件","slug":"中间件","permalink":"https://xwls.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"mq","slug":"mq","permalink":"https://xwls.github.io/tags/mq/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://xwls.github.io/tags/rabbitmq/"},{"name":"中间件","slug":"中间件","permalink":"https://xwls.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"Python 从 CSV 下载文件","slug":"python-download-file-from-csv","date":"2022-07-02T07:56:31.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/07/02/python-download-file-from-csv/","link":"","permalink":"https://xwls.github.io/2022/07/02/python-download-file-from-csv/","excerpt":"使用 python 读取 csv 文件，解析文件内的 url 并下载到本地。","text":"使用 python 读取 csv 文件，解析文件内的 url 并下载到本地。 CSV 文件img01,https://img.xxx.com/a/b/c/1.jpg img02,https://img.xxx.com/a/b/c/2.jpg img03,https://img.xxx.com/a/b/c/3.jpg img04,https://img.xxx.com/a/b/c/4.jpg Python 代码import csv import requests with open(&quot;urls.csv&quot;) as f: f_csv = csv.reader(f) for row in f_csv: img_name = row[0] img_url = row[1] file_path = &quot;./imgs/&quot;+img_name+&quot;.png&quot; r = requests.get(img_url) with open(file_path, &quot;wb&quot;) as save_file: save_file.write(r.content) print(img_name+&quot; download complete&quot;)","categories":[{"name":"Python","slug":"Python","permalink":"https://xwls.github.io/categories/Python/"}],"tags":[{"name":"util","slug":"util","permalink":"https://xwls.github.io/tags/util/"},{"name":"python","slug":"python","permalink":"https://xwls.github.io/tags/python/"}]},{"title":"Python 中 pip 设置为阿里镜像源","slug":"python-pip-aliyun-mirrors","date":"2022-07-01T07:47:42.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/07/01/python-pip-aliyun-mirrors/","link":"","permalink":"https://xwls.github.io/2022/07/01/python-pip-aliyun-mirrors/","excerpt":"Python 中的 pip 默认源，在国内下载很慢，修改为阿里云的 pip 源提升下载速度。","text":"Python 中的 pip 默认源，在国内下载很慢，修改为阿里云的 pip 源提升下载速度。 配置文件a. 找到下列文件 Linux 在~/.pip/pip.conf,Windows 在~/AppData/Roaming/pip/pip.ini b. 在上述文件中添加或修改： [global] index-url = https://mirrors.aliyun.com/pypi/simple/ [install] trusted-host=mirrors.aliyun.com 使用命令设置pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/","categories":[{"name":"Python","slug":"Python","permalink":"https://xwls.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://xwls.github.io/tags/python/"},{"name":"mirror","slug":"mirror","permalink":"https://xwls.github.io/tags/mirror/"}]},{"title":"Golang 并发编程示例","slug":"golang-concurrency","date":"2022-06-28T07:44:40.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/06/28/golang-concurrency/","link":"","permalink":"https://xwls.github.io/2022/06/28/golang-concurrency/","excerpt":"golang 并发编程的几个小例子","text":"golang 并发编程的几个小例子 Goroutinesfunc main() &#123; // A &quot;channel&quot; ch := make(chan string) // Start concurrent routines go push(&quot;Moe&quot;, ch) go push(&quot;Larry&quot;, ch) go push(&quot;Curly&quot;, ch) // Read 3 results // (Since our goroutines are concurrent, // the order isn&#39;t guaranteed!) fmt.Println(&lt;-ch, &lt;-ch, &lt;-ch) &#125; func push(name string, ch chan string) &#123; msg := &quot;Hey, &quot; + name + &quot;! &quot; ch &lt;- msg &#125; hey, Curly! hey, Moe! hey, Larry! Channels are concurrency-safe communication objects, used in goroutines. See: Goroutines, Channels Buffered channelsch := make(chan int, 2) ch &lt;- 1 ch &lt;- 2 ch &lt;- 3 // fatal error: // all goroutines are asleep - deadlock! fatal error: all goroutines are asleep - deadlock! Buffered channels limit the amount of messages it can keep. See: Buffered channels Closing channelsch &lt;- 1 ch &lt;- 2 ch &lt;- 3 close(ch) Iterates across a channel until its closed for i := range ch &#123; ··· &#125; Closed if ok &#x3D;&#x3D; false v, ok := &lt;- ch See: Range and close WaitGroupimport &quot;sync&quot; func main() &#123; var wg sync.WaitGroup for _, item := range itemList &#123; // Increment WaitGroup Counter wg.Add(1) go doOperation(&amp;wg, item) &#125; // Wait for goroutines to finish wg.Wait() &#125; func doOperation(wg *sync.WaitGroup, item string) &#123; defer wg.Done() // do operation on item // ... &#125; A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. The goroutine calls wg.Done() when it finishes. See: WaitGroup 参考资料 https://devhints.io/go","categories":[{"name":"Golang","slug":"Golang","permalink":"https://xwls.github.io/categories/Golang/"}],"tags":[{"name":"go","slug":"go","permalink":"https://xwls.github.io/tags/go/"}]},{"title":"hyper-v 占用其他软件或服务端口解决方案","slug":"hyper-v-port-use","date":"2022-06-14T07:38:14.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/06/14/hyper-v-port-use/","link":"","permalink":"https://xwls.github.io/2022/06/14/hyper-v-port-use/","excerpt":"hyper-v 占用其他软件或服务端口解决方案","text":"hyper-v 占用其他软件或服务端口解决方案 问题背景Windows 中有一个「TCP 动态端口范围」，处在这个范围内的端口，有时候会被一些服务占用。在 Windows Vista（或 Windows Server 2008）之前，动态端口范围是 1025 到 5000；在 Windows Vista（或 Windows Server 2008）之后，新的默认起始端口为 49152，新的默认结束端口为 65535。如果安装了 Hyper-V，那么 Hyper-V 会为容器宿主网络服务（Windows Container Host Networking Service）随机保留一些端口号使用。正常情况下，Hyper-V 虽然会在「TCP 动态端口范围」中随机挑一些端口号保留（占用），不过保留的端口号普遍比较大，就算保留几百、几千个也影响不大。但是，Windows 自动更新有时会出错，导致这个范围的起始端口被重置为 1024……这可就麻烦了，一些常用端口动不动就因为被保留而无法使用了。 使用命令查看目前「TCP 动态端口」的范围。 netsh int ipv4 show dynamicport tcp 这只是一个「待选择」范围，并不代表其中的所有端口都会被保留，只是有一部分会被 Hyper-V 征用。使用命令可以查看当前所有已经被征用了的端口。 netsh int ipv4 show excludedportrange protocol=tcp 如果这些被征用的端口范围随机挑选到 8088、8000、3000 等 Web 开发常用端口，那开发就会受到影响；如果挑选到其他应用软件要调用的端口，那这些应用软件就会受到影响，可以说非常坑爹了…… 在说正确的解决方法前，我们先说一个在 Stack Overflow 上看到的错误解决方法，这个方法还在好几个地方被提到过。 错误的解决方法错误的解决方法是，运行 net stop winnat 停止 winnat 服务，然后再运行 net start winnat 启动 winnat 服务。 这个方法本质上就是重启电脑的简化版……让 Hyper-V 再随机初始化一些端口保留，如果正好没随机到要用的端口，那一次成功。如果还是随机到了要用的端口，那就只能多来几次。 在那个问题的回答下，我看到有一些网友说「对我有用」，也有一些网友说「对我没用」，原因就是这个方法解决问题的概率完全是随机的…… 正确的解决方法正确的解决方法很简单，就是重新设置一下「TCP 动态端口范围」，让 Hyper-V 只在我们设定的范围内保留端口即可。可以以管理员权限运行下面的命令，将「TCP 动态端口范围」重新设定为 49152-65535。如果你觉得这个范围太大，还可以改小一点。 netsh int ipv4 set dynamic tcp start=49152 num=16384 netsh int ipv6 set dynamic tcp start=49152 num=16384 然后重启电脑即可。 重启电脑后，再运行命令 netsh int ipv4 show dynamicport tcp 查看动态端口范围，发现确实已经修改为了 49152-65535。现在只有这个范围内的端口可能会被保留了，基本不会影响日常使用。","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://xwls.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://xwls.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"windows","slug":"windows","permalink":"https://xwls.github.io/tags/windows/"}]},{"title":"Ubuntu 安装 Docker CE","slug":"ubuntu-install-docker-ce","date":"2022-05-09T07:34:51.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/05/09/ubuntu-install-docker-ce/","link":"","permalink":"https://xwls.github.io/2022/05/09/ubuntu-install-docker-ce/","excerpt":"Ubuntu 安装 Docker CE","text":"Ubuntu 安装 Docker CE # step 1: 安装必要的一些系统工具 sudo apt-get update sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common # step 2: 安装 GPG 证书 curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - # Step 3: 写入软件源信息 sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; # Step 4: 更新并安装 Docker-CE sudo apt-get -y update sudo apt-get -y install docker-ce # 安装指定版本的 Docker-CE: # Step 1: 查找 Docker-CE 的版本： # apt-cache madison docker-ce # docker-ce | 17.03.1~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages # docker-ce | 17.03.0~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages # Step 2: 安装指定版本的 Docker-CE: (VERSION 例如上面的 17.03.1~ce-0~ubuntu-xenial) # sudo apt-get -y install docker-ce=[VERSION]","categories":[{"name":"云原生","slug":"云原生","permalink":"https://xwls.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://xwls.github.io/tags/docker/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://xwls.github.io/tags/ubuntu/"}]},{"title":"Windows11 恢复右键菜单","slug":"win11-old-right-menu","date":"2022-05-09T05:45:13.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/05/09/win11-old-right-menu/","link":"","permalink":"https://xwls.github.io/2022/05/09/win11-old-right-menu/","excerpt":"刚刚安装的 win11，对新的右键菜单用不习惯（后来慢慢习惯了），此操作可以恢复 windows11 的右键菜单为原始样式。","text":"刚刚安装的 win11，对新的右键菜单用不习惯（后来慢慢习惯了），此操作可以恢复 windows11 的右键菜单为原始样式。 打开注册表使用WIN + R快捷键打开运行，输入regedit打开注册表编辑器 找到路径直接在路径中输入HKEY_CURRENT_USER\\Software\\Classes\\CLSID。 新建项 右键点击CLSID项，新建一个项，名为&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125; 右键点击新创建的项，再新建一个项，名为InprocServer32 选择新创建的项，双击右侧的默认条目，直接按下回车键 保存注册表后，重启电脑","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://xwls.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://xwls.github.io/tags/windows/"}]},{"title":"CentOS7 安装 Docker CE","slug":"centos7-install-docker-ce","date":"2022-05-06T05:35:28.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/05/06/centos7-install-docker-ce/","link":"","permalink":"https://xwls.github.io/2022/05/06/centos7-install-docker-ce/","excerpt":"Docker 有两个分支版本：Docker CE 和 Docker EE，即社区版和企业版。本教程基于 CentOS 7 安装 Docker CE。","text":"Docker 有两个分支版本：Docker CE 和 Docker EE，即社区版和企业版。本教程基于 CentOS 7 安装 Docker CE。 执行如下命令，安装 Docker 的依赖库。 yum install -y yum-utils device-mapper-persistent-data lvm2 执行如下命令，添加 Docker CE 的软件源信息。 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 执行如下命令，安装 Docker CE。 yum makecache fast yum -y install docker-ce 执行如下命令，启动 Docker 服务。 systemctl start docker Docker 的默认官方远程仓库是 hub.docker.com，由于网络原因，下载一个 Docker 官方镜像可能会需要很长的时间，甚至下载失败。为此，阿里云容器镜像服务 ACR 提供了官方的镜像站点，从而加速官方镜像的下载。下面介绍如何使用阿里云镜像仓库。 复制容器镜像服务控制台地址，在 FireFox 浏览器打开新页签，粘贴并访问云容器镜像服务控制台。 https://cr.console.aliyun.com/ 在容器镜像服务控制台左侧导航栏中，选择镜像工具&gt;镜像加速器。 在镜像加速器页面的加速器区域，单击复制。 切换至终端页面。执行如下命令配置 Docker 的自定义镜像仓库地址。请将下面命令中的镜像仓库地址https://kqh8****.mirror.aliyuncs.com 替换为上一步阿里云为您提供的专属镜像加速地址。 tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39; &#123; &quot;registry-mirrors&quot;: [&quot;https://kqh8****.mirror.aliyuncs.com&quot;] &#125; EOF 重新加载服务配置文件。 systemctl daemon-reload 重启 Docker 服务。 systemctl restart docker","categories":[{"name":"云原生","slug":"云原生","permalink":"https://xwls.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://xwls.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"centos","slug":"centos","permalink":"https://xwls.github.io/tags/centos/"},{"name":"linux","slug":"linux","permalink":"https://xwls.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://xwls.github.io/tags/docker/"}]},{"title":"Invalid calling convention 63","slug":"invalid-calling-convention-63","date":"2022-05-06T00:58:21.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/05/06/invalid-calling-convention-63/","link":"","permalink":"https://xwls.github.io/2022/05/06/invalid-calling-convention-63/","excerpt":"在 Java 中使用 jna 调用本地库的方法时，经常会有回调方法，回调方法在 Linux 和 Windows 中是有区别的，使用不正确会抛出异常：java.lang.IllegalArgumentException: Invalid calling convention 63","text":"在 Java 中使用 jna 调用本地库的方法时，经常会有回调方法，回调方法在 Linux 和 Windows 中是有区别的，使用不正确会抛出异常：java.lang.IllegalArgumentException: Invalid calling convention 63 异常日志Caused by: java.lang.IllegalArgumentException: Invalid calling convention 63 at com.sun.jna.Native.createNativeCallback(Native Method) ~[jna-5.4.0.jar!/:5.4.0 (b0)] at com.sun.jna.CallbackReference.&lt;init&gt;(CallbackReference.java:263) ~[jna-5.4.0.jar!/:5.4.0 (b0)] at com.sun.jna.CallbackReference.getFunctionPointer(CallbackReference.java:449) ~[jna-5.4.0.jar!/:5.4.0 (b0)] at com.sun.jna.CallbackReference.getFunctionPointer(CallbackReference.java:426) ~[jna-5.4.0.jar!/:5.4.0 (b0)] at com.sun.jna.Function.convertArgument(Function.java:558) ~[jna-5.4.0.jar!/:5.4.0 (b0)] at com.sun.jna.Function.invoke(Function.java:345) ~[jna-5.4.0.jar!/:5.4.0 (b0)] at com.sun.jna.Library$Handler.invoke(Library.java:265) ~[jna-5.4.0.jar!/:5.4.0 (b0)] at com.sun.proxy.$Proxy105.CLIENT_Init(Unknown Source) ~[na:na] at com.xs.dahua.module.LoginModule.init(LoginModule.java:37) ~[classes!/:0.0.1-SNAPSHOT] at com.xs.dahua.DahuaJavaServiceApplication.run(DahuaJavaServiceApplication.java:78) [classes!/:0.0.1-SNAPSHOT] at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:812) [spring-boot-2.5.12.jar!/:2.5.12] ... 13 common frames omitted 解决办法 Windows 下继承自com.sun.jna.win32.StdCallLibrary.StdCallCallback。 public interface fDisConnect extends StdCallCallback &#123; public void invoke(LLong lLoginID, String pchDVRIP, int nDVRPort, Pointer dwUser); &#125; Linux 下继承自com.sun.jna.Callback。 public interface fDisConnect extends Callback &#123; public void invoke(LLong lLoginID, String pchDVRIP, int nDVRPort, Pointer dwUser); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xwls.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xwls.github.io/tags/java/"},{"name":"jna","slug":"jna","permalink":"https://xwls.github.io/tags/jna/"},{"name":"exception","slug":"exception","permalink":"https://xwls.github.io/tags/exception/"}]},{"title":"Python 中的浅拷贝和深拷贝","slug":"python-deep-copy","date":"2022-04-30T09:19:27.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/04/30/python-deep-copy/","link":"","permalink":"https://xwls.github.io/2022/04/30/python-deep-copy/","excerpt":"学习 Python 的时候，关于浅拷贝和深拷贝不太懂，查阅资料时发现一个神奇的网站，对浅拷贝和深拷贝的理解帮助很大，非常直观","text":"学习 Python 的时候，关于浅拷贝和深拷贝不太懂，查阅资料时发现一个神奇的网站，对浅拷贝和深拷贝的理解帮助很大，非常直观 工具地址：https://pythontutor.com/live.html#mode=edit B 站地址：https://www.bilibili.com/video/BV1jT4y1G7AN import copy list1 = [1,2,3,[4,5,[6,7,8]]] # 浅拷贝 list2 = list1 list3 = list1[:] list4 = list1.copy() # 深拷贝 list5 = copy.deepcopy(list1)","categories":[{"name":"Python","slug":"Python","permalink":"https://xwls.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://xwls.github.io/tags/python/"},{"name":"bilibili","slug":"bilibili","permalink":"https://xwls.github.io/tags/bilibili/"},{"name":"在线工具","slug":"在线工具","permalink":"https://xwls.github.io/tags/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"}]},{"title":"RestTemplate 跳过 HTTPS 检查","slug":"rest-template-skip-ssl-check","date":"2022-04-30T03:43:05.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2022/04/30/rest-template-skip-ssl-check/","link":"","permalink":"https://xwls.github.io/2022/04/30/rest-template-skip-ssl-check/","excerpt":"使用 RestTemplate 请求 https 的接口时，遇到关于证书的错误。","text":"使用 RestTemplate 请求 https 的接口时，遇到关于证书的错误。 错误日志org.springframework.web.client.ResourceAccessException: I/O error on POST request for &quot;https://ceshi.bczzhsq.com/api/v1/cmu/dahua/GetNewLists&quot;: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target; nested exception is javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target ...... Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target at sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:141) at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:126) at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280) at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:434) ... 103 more 尝试使用 curl 访问[root@localhost dahua]# curl -X POST https://ceshi.bczzhsq.com/api/v1/cmu/dahua/GetNewLists curl: (60) Peer&#39;s Certificate issuer is not recognized. More details here: http://curl.haxx.se/docs/sslcerts.html curl performs SSL certificate verification by default, using a &quot;bundle&quot; of Certificate Authority (CA) public keys (CA certs). If the default bundle file isn&#39;t adequate, you can specify an alternate file using the --cacert option. If this HTTPS server uses a certificate signed by a CA represented in the bundle, the certificate verification probably failed due to a problem with the certificate (it might be expired, or the name might not match the domain name in the URL). If you&#39;d like to turn off curl&#39;s verification of the certificate, use the -k (or --insecure) option. 也不行 跳过 https 证书检查import org.apache.http.conn.ssl.SSLConnectionSocketFactory; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.client.HttpComponentsClientHttpRequestFactory; import org.springframework.http.converter.StringHttpMessageConverter; import org.springframework.web.client.RestTemplate; import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; import java.nio.charset.StandardCharsets; /** * Web 相关配置 * * @author WZW 2022-04-23 10:15 */ @Configuration public class WebConfig &#123; /** * 构造 RestTemplate * * @return RestTemplate * @throws Exception */ @Bean public RestTemplate restTemplate() throws Exception &#123; HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(); // 超时 factory.setConnectionRequestTimeout(5000); factory.setConnectTimeout(5000); factory.setReadTimeout(5000); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(createIgnoreVerifySSL(), // 指定 TLS 版本 null, // 指定算法 null, // 取消域名验证 (string, ssls) -&gt; true); CloseableHttpClient httpClient = HttpClients.custom().setSSLSocketFactory(sslsf).build(); factory.setHttpClient(httpClient); RestTemplate restTemplate = new RestTemplate(factory); // 解决中文乱码问题 restTemplate.getMessageConverters().set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8)); return restTemplate; &#125; /** * 跳过证书效验的 SSLContext * * @return SSLContext * @throws Exception */ private static SSLContext createIgnoreVerifySSL() throws Exception &#123; SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;); // 实现一个 X509TrustManager 接口，用于绕过验证，不用修改里面的方法 X509TrustManager trustManager = new X509TrustManager() &#123; @Override public void checkClientTrusted(java.security.cert.X509Certificate[] paramArrayOfX509Certificate, String paramString) &#123; &#125; @Override public void checkServerTrusted(java.security.cert.X509Certificate[] paramArrayOfX509Certificate, String paramString) &#123; &#125; @Override public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123; return null; &#125; &#125;; sc.init(null, new TrustManager[]&#123;trustManager&#125;, null); return sc; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://xwls.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xwls.github.io/tags/java/"},{"name":"https","slug":"https","permalink":"https://xwls.github.io/tags/https/"},{"name":"spring","slug":"spring","permalink":"https://xwls.github.io/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://xwls.github.io/tags/springboot/"},{"name":"ssl","slug":"ssl","permalink":"https://xwls.github.io/tags/ssl/"}]},{"title":"工具方法-判断当前时间是否在指定时间范围","slug":"date-time-range-util","date":"2020-08-13T05:43:09.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2020/08/13/date-time-range-util/","link":"","permalink":"https://xwls.github.io/2020/08/13/date-time-range-util/","excerpt":"项目中遇到一个需求，简单来说就是预约和抢购，预约有开始时间和结束时间，抢购也有开始时间和结束时间，这些时间只需要在数据库中存储的是 time 类型，因为只需要小时分钟秒，不需要年月日。分享几个工具方法，用来比较当前时间是否在指定时间范围。","text":"项目中遇到一个需求，简单来说就是预约和抢购，预约有开始时间和结束时间，抢购也有开始时间和结束时间，这些时间只需要在数据库中存储的是 time 类型，因为只需要小时分钟秒，不需要年月日。分享几个工具方法，用来比较当前时间是否在指定时间范围。 Golang//当前时间是否在指定范围内 //参数为时间字符串，格式为&quot;时：分：秒&quot; func IsNowInTimeRange(startTimeStr, endTimeStr string) bool &#123; //当前时间 now := time.Now() //当前时间转换为&quot;年-月-日&quot;的格式 format := now.Format(&quot;2006-01-02&quot;) //转换为 time 类型需要的格式 layout := &quot;2006-01-02 15:04:05&quot; //将开始时间拼接“年-月-日 ”转换为 time 类型 timeStart, _ := time.ParseInLocation(layout, format+&quot; &quot;+startTimeStr, time.Local) //将结束时间拼接“年-月-日 ”转换为 time 类型 timeEnd, _ := time.ParseInLocation(layout, format+&quot; &quot;+endTimeStr, time.Local) //使用 time 的 Before 和 After 方法，判断当前时间是否在参数的时间范围 return now.Before(timeEnd) &amp;&amp; now.After(timeStart) &#125; Java/** * 判断当前时间是否在指定时间内 * @param startTimeStr 开始时间 * @param endTimeStr 结束时间 * @return true：在；false：不在 */ public static boolean isNowInTimeRange(String startTimeStr, String endTimeStr) &#123; LocalTime startTime = LocalTime.parse(startTimeStr); LocalTime endTime = LocalTime.parse(endTimeStr); int startCompare = startTime.compareTo(LocalTime.now()); int endCompare = endTime.compareTo(LocalTime.now()); return startCompare* endCompare &lt;= 0; &#125; C/// &lt;summary&gt; /// 判断当前时间是否在时间段之间 /// &lt;/summary&gt; /// &lt;param name=&quot;startTime&quot;&gt;开始时间&lt;/param&gt; /// &lt;param name=&quot;endTime&quot;&gt;结束时间&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool NowTimeBetweenTwoTimes(string startTimeStr, string endTimeStr, int serverTimeStamp) &#123; // 解析时间 DateTime startTime = DateTime.Parse(startTimeStr); DateTime endTime = DateTime.Parse(endTimeStr); TimeZone.CurrentTimeZone.ToLocalTime(new System.DateTime(1970, 1, 1)); DateTime serverTime = TimeStampToDateTime(serverTimeStamp); // t1 小于 t2 小于零 t1 等于 t2 等于零 t1 大于 t2 大于零 int startCompare = DateTime.Compare(startTime, serverTime); int endCompare = DateTime.Compare(endTime, serverTime); return startCompare * endCompare &lt;= 0; &#125;","categories":[{"name":"Util","slug":"Util","permalink":"https://xwls.github.io/categories/Util/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xwls.github.io/tags/java/"},{"name":"golang","slug":"golang","permalink":"https://xwls.github.io/tags/golang/"},{"name":"c#","slug":"c","permalink":"https://xwls.github.io/tags/c/"},{"name":"util","slug":"util","permalink":"https://xwls.github.io/tags/util/"}]},{"title":"SpringBoot 整合 Shiro 实现认证和授权","slug":"springboot-shiro","date":"2019-12-27T05:47:04.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2019/12/27/springboot-shiro/","link":"","permalink":"https://xwls.github.io/2019/12/27/springboot-shiro/","excerpt":"Shiro 是 Apache 软件基金会下有名的安全框架，本文记录在 SpringBoot 中如何使用 Shiro 实现用户认证及授权。","text":"Shiro 是 Apache 软件基金会下有名的安全框架，本文记录在 SpringBoot 中如何使用 Shiro 实现用户认证及授权。 用户认证和授权自定义 Realm 完成用户的认证和授权，这里使用模拟数据，规定如下： 用户名输入”unknown”，表示用户名不存在 用户 tom，密码 123456 用户 jerry，密码 123456 import org.apache.shiro.authc.*; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.apache.shiro.util.ByteSource; /** * 自定义 Realm 继承自 AuthenticatingRealm 完成用户认证和授权 */ public class MyShiroRealm extends AuthorizingRealm &#123; @Override //此方法用来完成用户认证 protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; //1. 将 token 转换为 UsernamePasswordToken UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; //2. 从 token 获取用户名 String username = token.getUsername(); //3. 从数据库根据用户名查询用户信息 System.out.println(&quot;从数据库查询、&quot;&quot; + username + &quot;\\&quot;用户。&quot;); //4. 根据查询结果判断用户状态 if (&quot;unknown&quot;.equals(username)) &#123; throw new UnknownAccountException(&quot;账号不存在&quot;); &#125; //盐值加密 // String password = &quot;123456&quot;; //5. 进行认证 //1). principal：当前登录的用户名或者该用户名对应的实体对象 String principal = username; //2). credentials：加密之后的密码 String credentials = &quot;&quot;; if (&quot;tom&quot;.equals(username)) &#123; credentials = &quot;a7ffa5d8b1b4f5f1e8492623147bccf0&quot;; &#125; else if (&quot;jerry&quot;.equals(username)) &#123; credentials = &quot;6b2244d0a6fca5f5dc590437d3ca6781&quot;; &#125; //3). 当前使用的 Realm 的名字，可以直接调用 getName 方法获取 String realmName = getName(); //credentials：加密之后的密码 //credentialsSalt：盐值，需要保证盐值唯一 ByteSource credentialsSalt = ByteSource.Util.bytes(username); return new SimpleAuthenticationInfo(principal, credentials, credentialsSalt, realmName); &#125; //完成授权的方法 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; System.out.println(&quot;principalCollection = &quot; + principalCollection); //1. 获取当前登录的用户 Object username = principalCollection.getPrimaryPrincipal(); //2. 获取当前登录用户的角色和权限 //1). 第一种方式：去数据库查询 //2). 第二种方式： // 认证成功之后，将用户的角色和权限保存在用户的实体对象中，每次授权时，从实体对象的属性获取 SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); if (&quot;tom&quot;.equals(username)) &#123; simpleAuthorizationInfo.addStringPermission(&quot;book:link&quot;); simpleAuthorizationInfo.addStringPermission(&quot;book:save&quot;); simpleAuthorizationInfo.addStringPermission(&quot;book:remove&quot;); &#125; else if (&quot;jerry&quot;.equals(username)) &#123; simpleAuthorizationInfo.addStringPermission(&quot;student:link&quot;); simpleAuthorizationInfo.addStringPermission(&quot;student:remove&quot;); simpleAuthorizationInfo.addStringPermission(&quot;student:edit&quot;); &#125; //3. 构建 AuthorizationInfo 对象并返回 return simpleAuthorizationInfo; &#125; &#125; Shiro 相关的配置import at.pollux.thymeleaf.shiro.dialect.ShiroDialect; import org.apache.shiro.authc.credential.HashedCredentialsMatcher; import org.apache.shiro.codec.Base64; import org.apache.shiro.mgt.SecurityManager; import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor; import org.apache.shiro.spring.web.ShiroFilterFactoryBean; import org.apache.shiro.web.mgt.CookieRememberMeManager; import org.apache.shiro.web.mgt.DefaultWebSecurityManager; import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.LinkedHashMap; import java.util.Map; @Configuration public class ShiroConfig &#123; //配置密码加密方式，这里是有 MD5 盐值加密 10 次 @Bean public HashedCredentialsMatcher hashedCredentialsMatcher() &#123; //构造方法传入加密方式 HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(&quot;md5&quot;); //设置加密次数 credentialsMatcher.setHashIterations(10); return credentialsMatcher; &#125; //配置 Realm @Bean public MyShiroRealm shiroRealm(HashedCredentialsMatcher hashedCredentialsMatcher) &#123; MyShiroRealm myShiroRealm = new MyShiroRealm(); myShiroRealm.setCredentialsMatcher(hashedCredentialsMatcher); return myShiroRealm; &#125; //配置 SecurityManager @Bean public SecurityManager securityManager(MyShiroRealm shiroRealm, CookieRememberMeManager cookieRememberMeManager) &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRememberMeManager(cookieRememberMeManager); securityManager.setRealm(shiroRealm); return securityManager; &#125; //配置 ShiroFilterFactoryBean @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) &#123; ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean(); factoryBean.setSecurityManager(securityManager); factoryBean.setLoginUrl(&quot;/login&quot;); factoryBean.setSuccessUrl(&quot;/index&quot;); factoryBean.setUnauthorizedUrl(&quot;/403&quot;); Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(); //anon：可以匿名访问，不需要认证 map.put(&quot;/css/**&quot;, &quot;anon&quot;); map.put(&quot;/img/**&quot;, &quot;anon&quot;); map.put(&quot;/login&quot;, &quot;anon&quot;); //注销，退出登录 map.put(&quot;/logout&quot;, &quot;logout&quot;); //authc：需要认证才能方法 map.put(&quot;/&quot;, &quot;authc&quot;); // map.put(&quot;/book&quot;,&quot;perms[book]&quot;); // map.put(&quot;/student&quot;,&quot;perms[student]&quot;); map.put(&quot;/index&quot;, &quot;user&quot;);//记住我登录可以访问 map.put(&quot;/**&quot;, &quot;authc&quot;); factoryBean.setFilterChainDefinitionMap(map); return factoryBean; &#125; //使用注解校验权限需要配置 @Bean public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() &#123; DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator(); defaultAdvisorAutoProxyCreator.setProxyTargetClass(true); return defaultAdvisorAutoProxyCreator; &#125; //使用注解校验权限需要配置 @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; &#125; //配置 Thymeleaf 整合 Shiro，可以使用 shiro:xx 标签 @Bean public ShiroDialect shiroDialect() &#123; return new ShiroDialect(); &#125; //实现记住我功能 @Bean public CookieRememberMeManager cookieRememberMeManager() &#123; CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager(); //设置 cookie 的有效期为 1 个月 cookieRememberMeManager.getCookie().setMaxAge(60 * 60 * 24 * 30); //设置加密密钥，密码可以自行替换，生成方式下面有介绍 cookieRememberMeManager.setCipherKey(Base64.decode(&quot;Jt3C93kMR9D5e8QzwfsiMw==&quot;)); return cookieRememberMeManager; &#125; &#125; 记住我功能密钥生成方式KeyGenerator aes = KeyGenerator.getInstance(&quot;AES&quot;); SecretKey secretKey = aes.generateKey(); byte[] encoded = secretKey.getEncoded(); String s = Base64.encodeToString(encoded); System.out.println(s);","categories":[{"name":"Java","slug":"Java","permalink":"https://xwls.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xwls.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://xwls.github.io/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://xwls.github.io/tags/springboot/"},{"name":"shiro","slug":"shiro","permalink":"https://xwls.github.io/tags/shiro/"}]},{"title":"Windows 下安装 MySQL5.7.28 压缩版","slug":"windows-install-mysql-57-zip","date":"2019-10-24T05:50:15.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2019/10/24/windows-install-mysql-57-zip/","link":"","permalink":"https://xwls.github.io/2019/10/24/windows-install-mysql-57-zip/","excerpt":"关于 MySQL，之前大部分都是在 Linux 下安装使用，在 Windows 下也用过，但用的都是安装版，这里记录一下 Windows 下 MySQL 压缩版的安装和配置过程。","text":"关于 MySQL，之前大部分都是在 Linux 下安装使用，在 Windows 下也用过，但用的都是安装版，这里记录一下 Windows 下 MySQL 压缩版的安装和配置过程。 下载浏览器访问 https://dev.mysql.com/downloads/mysql/ 下载需要的版本，我这里下载的是 Windows64 位的压缩版。 解压安装将下载的的压缩文件 mysql-5.7.28-winx64.zip 解压缩到你准备安装的目录，并在压缩目录中创建文件 my.ini，文件内容如下： 其中 basedir 为 MySQL 的解压缩目录 [mysql] # 设置 mysql 客户端默认字符集 default-character-set=utf8 [mysqld] #设置 3306 端口 port = 3306 # 设置 mysql 的安装目录 basedir=D:\\mysql-5.7.28-winx64 # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为 8 比特编码的 latin1 字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 将 MySQL 安装目录下的 bin 目录添加到环境变量 Path 以管理员身份打开 CMD，进入 MySQL 的 bin 目录，执行以下命令安装服务 mysqld -install # or：mysqld -install MySQL57，其中 MySQL57 表示服务名 安装完成之后，打开服务应该可以看到刚刚安装的服务 初始化 开始初始化，初始化完成后会输出随机生成的 root 密码 mysqld --initialize --console 红框中的是生成的 root 密码 设置 root 密码 启动 MySQL 的服务，然后使用刚刚生成的 root 密码登录到 MySQL mysql -uroot -p 将 root 密码修改为 123456 set password = password(&#39;123456&#39;);","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://xwls.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://xwls.github.io/tags/mysql/"},{"name":"windows","slug":"windows","permalink":"https://xwls.github.io/tags/windows/"}]},{"title":"CentOS 安装 MySQL5.7","slug":"centos7-install-mysql57","date":"2019-10-22T06:04:37.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2019/10/22/centos7-install-mysql57/","link":"","permalink":"https://xwls.github.io/2019/10/22/centos7-install-mysql57/","excerpt":"记录一下在 CentOS7 中安装 MySQL5.7 版本遇到的一个小问题，顺便记录下安装过程","text":"记录一下在 CentOS7 中安装 MySQL5.7 版本遇到的一个小问题，顺便记录下安装过程 安装 MySQL5.7 的安装源yum localinstall http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm 安装 MySQL5.7yum install mysql-community-server 启动并设置开机自启systemctl start mysqld systemctl enable mysqld 查看 root 密码grep &#39;temporary password&#39; /var/log/mysqld.log 可以看到我这边的密码为：:&#x2F;XaahH&amp;%5Qe，是的，包含开始的冒号，我一开始以为冒号后边才是，试了几次发现不对，冒号也是！！！ 注意这个密码只能够让你登录到 MySQL，登录进去之后必须马上修改密码，否则无法进行其他任何的操作。 修改 root 密码（本篇重点）修改密码的命令： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;; 我希望给 root 设置一个简单的密码，比如 123456，但是发现并不可以 意思是说我的密码太过简单不符合他的密码策略，但是我想查询或者修改密码策略必须先设置密码才可以，无奈之下，先设置一个复杂的： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;OracleOAEC$2019&#39;; 密码设置好了，接下来看下密码策略： SHOW VARIABLES LIKE &#39;validate_password%&#39;; 这里挑了几个说明下： 我想设置的密码是简单密码 123456，需要将 validate_password_policy 设置为 LOW，设置为 LOW 之后就只验证长度，同时还需要设置 validate_password_length 为 6： set global validate_password_policy=LOW; set global validate_password_length=6; 然后再尝试修改密码为 123456： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; 可以发现，密码已经成功修改为 123456 允许 root 远程登录GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION; FLUSH PRIVILEGES;","categories":[{"name":"运维","slug":"运维","permalink":"https://xwls.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://xwls.github.io/tags/centos/"},{"name":"linux","slug":"linux","permalink":"https://xwls.github.io/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"https://xwls.github.io/tags/mysql/"}]},{"title":"Nginx 配置 http 自动跳转到 https","slug":"nginx-http-auto-redirect-https","date":"2019-10-22T05:58:42.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2019/10/22/nginx-http-auto-redirect-https/","link":"","permalink":"https://xwls.github.io/2019/10/22/nginx-http-auto-redirect-https/","excerpt":"前几天在阿里云申请了一个免费的 SSL 证书，给网站配置了 https 访问，顺便配置了 http 自动跳转到 https，在这里记录下配置文件。","text":"前几天在阿里云申请了一个免费的 SSL 证书，给网站配置了 https 访问，顺便配置了 http 自动跳转到 https，在这里记录下配置文件。 nginx.config upstream halo_server&#123; server 172.31.10.131:8090; &#125; server &#123; listen 80; server_name www.xwls.me; return 301 https://$server_name$request_uri; &#125; # Settings for a TLS enabled server. # server &#123; listen 443; server_name www.xwls.me; ssl on; root html; index index.html index.htm; ssl_certificate /home/ec2-user/2728032_xwls.me.pem; ssl_certificate_key /home/ec2-user/2728032_xwls.me.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; # root html; # index index.html index.htm; proxy_pass http://halo_server; &#125; &#125;","categories":[{"name":"运维","slug":"运维","permalink":"https://xwls.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://xwls.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"https","slug":"https","permalink":"https://xwls.github.io/tags/https/"},{"name":"http","slug":"http","permalink":"https://xwls.github.io/tags/http/"}]},{"title":"Linux 源码安装 Nginx","slug":"linux-install-nginx-by-source","date":"2019-08-26T06:21:23.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2019/08/26/linux-install-nginx-by-source/","link":"","permalink":"https://xwls.github.io/2019/08/26/linux-install-nginx-by-source/","excerpt":"在 CentOS7 下以软件源码包的方式安装 Nginx，主要分为：下载、解压缩、配置、编译、安装几个步骤，其他源码包软件的安装方式类似。","text":"在 CentOS7 下以软件源码包的方式安装 Nginx，主要分为：下载、解压缩、配置、编译、安装几个步骤，其他源码包软件的安装方式类似。 安装 nginx 需要的依赖# 安装 gcc yum install -y gcc # 安装 gcc-c++ yum install -y gcc-c++ # 安装 pcre pcre-devel yum install -y pcre pcre-devel # 安装 zlib zlib-devel yum install -y zlib zlib-devel # 安装 openssl openssl-devel yum install -y openssl openssl-devel 下载wget http://nginx.org/download/nginx-1.16.1.tar.gz 解压缩tar -zxvf nginx-1.16.1.tar.gz 安装# 进入解压得到的目录 cd nginx-1.16.1 # 配置 ./configure # 编译 make # 安装 make install 启动、停止# 进入/usr/local/nginx/sbin cd /usr/local/nginx/sbin # 启动 ./nginx # 停止 ./nginx -s stop # 重启 ./nginx -s reload","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"https://xwls.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://xwls.github.io/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"https://xwls.github.io/tags/nginx/"}]},{"title":"Nginx 配置负载均衡","slug":"nginx-loadbalance","date":"2019-08-26T06:16:58.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2019/08/26/nginx-loadbalance/","link":"","permalink":"https://xwls.github.io/2019/08/26/nginx-loadbalance/","excerpt":"负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。接下来以两个 Tomcat 为例简单说一下 Nginx 如何配置负载均衡。","text":"负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。接下来以两个 Tomcat 为例简单说一下 Nginx 如何配置负载均衡。 配置 nginx.confupstream tomcat&#123; # 服务器性能较好，权重设置为 2 server 192.168.0.100:8080 weight=2; # 服务器性能较弱，权重设置为 1 server 192.168.0.101:8080 weight=1; &#125; server &#123; listen 80; server_name localhost; #access_log logs/host.access.log main; location / &#123; #root html; #index index.html index.htm; proxy_pass http://tomcat; &#125; &#125; 效果每三个请求，会有两个访问 8080 服务器，一个访问 8081 服务器","categories":[{"name":"运维","slug":"运维","permalink":"https://xwls.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://xwls.github.io/tags/nginx/"}]},{"title":"SpringBoot中Jackson的简单使用","slug":"springboot-jackson","date":"2019-08-12T05:38:42.000Z","updated":"2023-08-18T03:56:18.118Z","comments":true,"path":"2019/08/12/springboot-jackson/","link":"","permalink":"https://xwls.github.io/2019/08/12/springboot-jackson/","excerpt":"SpringBoot默认使用Jackson作为对象的序列化工具，在进行对象的序列化时，日期时间类型和null值往往需要单独处理。","text":"SpringBoot默认使用Jackson作为对象的序列化工具，在进行对象的序列化时，日期时间类型和null值往往需要单独处理。 统一处理在SpringBoot的配置文件application.yml中添加以下配置： spring: jackson: #时区 time-zone: GMT+8 #日期格式 date-format: yyyy-MM-dd HH:mm:ss #只对非空属性进行序列化 default-property-inclusion: non_null 单独处理 处理日期格式 //格式化日期属性 @JsonFormat(pattern = &quot;yyyy年MM月dd日&quot;) private Date birthday; 序列化时忽略属性 //不对密码进行序列化 @JsonIgnore private String password; 为属性重命名 //属性email会在序列化时重命名为mail @JsonProperty(&quot;mail&quot;) private String email;","categories":[{"name":"Java","slug":"Java","permalink":"https://xwls.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xwls.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://xwls.github.io/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://xwls.github.io/tags/springboot/"},{"name":"json","slug":"json","permalink":"https://xwls.github.io/tags/json/"}]}],"categories":[{"name":"云原生","slug":"云原生","permalink":"https://xwls.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"},{"name":"小技巧","slug":"小技巧","permalink":"https://xwls.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://xwls.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"Java","slug":"Java","permalink":"https://xwls.github.io/categories/Java/"},{"name":"大数据","slug":"大数据","permalink":"https://xwls.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"数据库","slug":"数据库","permalink":"https://xwls.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"中间件","slug":"中间件","permalink":"https://xwls.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Python","slug":"Python","permalink":"https://xwls.github.io/categories/Python/"},{"name":"Golang","slug":"Golang","permalink":"https://xwls.github.io/categories/Golang/"},{"name":"Util","slug":"Util","permalink":"https://xwls.github.io/categories/Util/"},{"name":"运维","slug":"运维","permalink":"https://xwls.github.io/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"k8s","slug":"k8s","permalink":"https://xwls.github.io/tags/k8s/"},{"name":"Ingress","slug":"Ingress","permalink":"https://xwls.github.io/tags/Ingress/"},{"name":"灰度","slug":"灰度","permalink":"https://xwls.github.io/tags/%E7%81%B0%E5%BA%A6/"},{"name":"git","slug":"git","permalink":"https://xwls.github.io/tags/git/"},{"name":"docker","slug":"docker","permalink":"https://xwls.github.io/tags/docker/"},{"name":"mac","slug":"mac","permalink":"https://xwls.github.io/tags/mac/"},{"name":"redis","slug":"redis","permalink":"https://xwls.github.io/tags/redis/"},{"name":"集群","slug":"集群","permalink":"https://xwls.github.io/tags/%E9%9B%86%E7%BE%A4/"},{"name":"java","slug":"java","permalink":"https://xwls.github.io/tags/java/"},{"name":"数据库","slug":"数据库","permalink":"https://xwls.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"存储过程","slug":"存储过程","permalink":"https://xwls.github.io/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"},{"name":"mybatis","slug":"mybatis","permalink":"https://xwls.github.io/tags/mybatis/"},{"name":"源码","slug":"源码","permalink":"https://xwls.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"算法","slug":"算法","permalink":"https://xwls.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://xwls.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"大数据","slug":"大数据","permalink":"https://xwls.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Hadoop","slug":"Hadoop","permalink":"https://xwls.github.io/tags/Hadoop/"},{"name":"Mac","slug":"Mac","permalink":"https://xwls.github.io/tags/Mac/"},{"name":"运维","slug":"运维","permalink":"https://xwls.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"centos","slug":"centos","permalink":"https://xwls.github.io/tags/centos/"},{"name":"linux","slug":"linux","permalink":"https://xwls.github.io/tags/linux/"},{"name":"oracle","slug":"oracle","permalink":"https://xwls.github.io/tags/oracle/"},{"name":"mq","slug":"mq","permalink":"https://xwls.github.io/tags/mq/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://xwls.github.io/tags/rabbitmq/"},{"name":"中间件","slug":"中间件","permalink":"https://xwls.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"util","slug":"util","permalink":"https://xwls.github.io/tags/util/"},{"name":"python","slug":"python","permalink":"https://xwls.github.io/tags/python/"},{"name":"mirror","slug":"mirror","permalink":"https://xwls.github.io/tags/mirror/"},{"name":"go","slug":"go","permalink":"https://xwls.github.io/tags/go/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://xwls.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"windows","slug":"windows","permalink":"https://xwls.github.io/tags/windows/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://xwls.github.io/tags/ubuntu/"},{"name":"jna","slug":"jna","permalink":"https://xwls.github.io/tags/jna/"},{"name":"exception","slug":"exception","permalink":"https://xwls.github.io/tags/exception/"},{"name":"bilibili","slug":"bilibili","permalink":"https://xwls.github.io/tags/bilibili/"},{"name":"在线工具","slug":"在线工具","permalink":"https://xwls.github.io/tags/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"},{"name":"https","slug":"https","permalink":"https://xwls.github.io/tags/https/"},{"name":"spring","slug":"spring","permalink":"https://xwls.github.io/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://xwls.github.io/tags/springboot/"},{"name":"ssl","slug":"ssl","permalink":"https://xwls.github.io/tags/ssl/"},{"name":"golang","slug":"golang","permalink":"https://xwls.github.io/tags/golang/"},{"name":"c#","slug":"c","permalink":"https://xwls.github.io/tags/c/"},{"name":"shiro","slug":"shiro","permalink":"https://xwls.github.io/tags/shiro/"},{"name":"mysql","slug":"mysql","permalink":"https://xwls.github.io/tags/mysql/"},{"name":"http","slug":"http","permalink":"https://xwls.github.io/tags/http/"},{"name":"nginx","slug":"nginx","permalink":"https://xwls.github.io/tags/nginx/"},{"name":"json","slug":"json","permalink":"https://xwls.github.io/tags/json/"}]}